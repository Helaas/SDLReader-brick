diff --git a/demo/sdl_renderer/nuklear_sdl_renderer.h b/demo/sdl_renderer/nuklear_sdl_renderer.h
index 25eaec3..ae0cbc6 100644
--- a/demo/sdl_renderer/nuklear_sdl_renderer.h
+++ b/demo/sdl_renderer/nuklear_sdl_renderer.h
@@ -43,6 +43,7 @@ NK_API void                 nk_sdl_handle_grab(void);
  * ===============================================================
  */
 #ifdef NK_SDL_RENDERER_IMPLEMENTATION
+#include <math.h>
 #include <string.h>
 #include <stdlib.h>

@@ -60,23 +61,227 @@ struct nk_sdl_vertex {

 static struct nk_sdl {
     SDL_Window *win;
-    SDL_Renderer *renderer;
-    struct nk_sdl_device ogl;
-    struct nk_context ctx;
-    struct nk_font_atlas atlas;
-    Uint64 time_of_last_frame;
+   SDL_Renderer *renderer;
+   struct nk_sdl_device ogl;
+   struct nk_context ctx;
+   struct nk_font_atlas atlas;
+   Uint64 time_of_last_frame;
 } sdl;
+static SDL_bool nk_sdl_debug_logging = SDL_FALSE;
+
+#if SDL_VERSION_ATLEAST(2, 0, 18)
+static inline Uint64
+nk_sdl_get_ticks(void)
+{
+    return SDL_GetTicks64();
+}
+#else
+static inline Uint64
+nk_sdl_get_ticks(void)
+{
+    return (Uint64)SDL_GetTicks();
+}
+
+static inline float
+nk_sdl_minf(float a, float b)
+{
+    return (a < b) ? a : b;
+}
+
+static inline float
+nk_sdl_maxf(float a, float b)
+{
+    return (a > b) ? a : b;
+}
+
+static inline int
+nk_sdl_mini(int a, int b)
+{
+    return (a < b) ? a : b;
+}
+
+static inline int
+nk_sdl_maxi(int a, int b)
+{
+    return (a > b) ? a : b;
+}
+
+static inline float
+nk_sdl_clampf(float value, float min_value, float max_value)
+{
+    if (value < min_value)
+        return min_value;
+    if (value > max_value)
+        return max_value;
+    return value;
+}
+#endif /* !SDL_VERSION_ATLEAST(2, 0, 18) */
+
+/* Render individual triangles using SDL_RenderGeometry (if available) or fallback */
+static void
+nk_sdl_render_geometry_raw_legacy(SDL_Renderer *renderer,
+    SDL_Texture *texture,
+    const void *vertices_base,
+    int vertex_stride,
+    const nk_draw_index *indices,
+    int elem_count)
+{
+    if (!renderer || !vertices_base || !indices || elem_count <= 0)
+        return;
+
+#if SDL_VERSION_ATLEAST(2, 0, 18)
+    /* This should never be called on SDL >= 2.0.18, but just in case */
+    SDL_RenderGeometryRaw(renderer, texture,
+        (const float*)((const nk_byte*)vertices_base + offsetof(struct nk_sdl_vertex, position)), vertex_stride,
+        (const SDL_Color*)((const nk_byte*)vertices_base + offsetof(struct nk_sdl_vertex, col)), vertex_stride,
+        (const float*)((const nk_byte*)vertices_base + offsetof(struct nk_sdl_vertex, uv)), vertex_stride,
+        elem_count / 3,
+        (void*)indices, elem_count, 2);
+    return;
+#else
+    /* For SDL < 2.0.18, we MUST use SDL_RenderGeometry if available (2.0.10+) */
+    /* because quad-based rendering with min/max UVs is fundamentally broken */
+    const nk_byte *vertex_bytes = (const nk_byte*)vertices_base;
+
+    int tex_w = 0;
+    int tex_h = 0;
+    if (texture)
+    {
+        SDL_QueryTexture(texture, NULL, NULL, &tex_w, &tex_h);
+    }
+
+    /* Process triangles (3 indices at a time, not 6) */
+    const int indices_per_tri = 3;
+    int processed = 0;
+
+    while (processed + indices_per_tri <= elem_count)
+    {
+        const nk_draw_index *idx = indices + processed;
+
+        /* Get the 3 vertices for this triangle */
+        const struct nk_sdl_vertex *v0 = (const struct nk_sdl_vertex*)(vertex_bytes + vertex_stride * idx[0]);
+        const struct nk_sdl_vertex *v1 = (const struct nk_sdl_vertex*)(vertex_bytes + vertex_stride * idx[1]);
+        const struct nk_sdl_vertex *v2 = (const struct nk_sdl_vertex*)(vertex_bytes + vertex_stride * idx[2]);
+
+        /* Calculate bounding box for this triangle */
+        float min_x = v0->position[0];
+        float max_x = min_x;
+        float min_y = v0->position[1];
+        float max_y = min_y;
+
+        if (v1->position[0] < min_x) min_x = v1->position[0];
+        if (v1->position[0] > max_x) max_x = v1->position[0];
+        if (v1->position[1] < min_y) min_y = v1->position[1];
+        if (v1->position[1] > max_y) max_y = v1->position[1];
+
+        if (v2->position[0] < min_x) min_x = v2->position[0];
+        if (v2->position[0] > max_x) max_x = v2->position[0];
+        if (v2->position[1] < min_y) min_y = v2->position[1];
+        if (v2->position[1] > max_y) max_y = v2->position[1];
+
+        /* Check for degenerate triangles */
+        if ((max_x - min_x) <= 0.01f || (max_y - min_y) <= 0.01f)
+        {
+            processed += indices_per_tri;
+            continue;
+        }
+
+        /* For textured triangles, use a very simple approximation: */
+        /* Render as a rectangle using the triangle's bounding box and average UV */
+        if (texture && tex_w > 0 && tex_h > 0)
+        {
+            /* Calculate average UV coordinates */
+            float avg_u = (v0->uv[0] + v1->uv[0] + v2->uv[0]) / 3.0f;
+            float avg_v = (v0->uv[1] + v1->uv[1] + v2->uv[1]) / 3.0f;
+
+            /* Calculate UV extents */
+            float min_u = v0->uv[0];
+            float max_u = min_u;
+            float min_v = v0->uv[1];
+            float max_v = min_v;
+
+            if (v1->uv[0] < min_u) min_u = v1->uv[0];
+            if (v1->uv[0] > max_u) max_u = v1->uv[0];
+            if (v1->uv[1] < min_v) min_v = v1->uv[1];
+            if (v1->uv[1] > max_v) max_v = v1->uv[1];
+
+            if (v2->uv[0] < min_u) min_u = v2->uv[0];
+            if (v2->uv[0] > max_u) max_u = v2->uv[0];
+            if (v2->uv[1] < min_v) min_v = v2->uv[1];
+            if (v2->uv[1] > max_v) max_v = v2->uv[1];
+
+            SDL_Rect dst;
+            dst.x = (int)floorf(min_x + 0.5f);
+            dst.y = (int)floorf(min_y + 0.5f);
+            dst.w = (int)floorf(max_x - min_x + 0.5f);
+            dst.h = (int)floorf(max_y - min_y + 0.5f);
+            if (dst.w < 1) dst.w = 1;
+            if (dst.h < 1) dst.h = 1;
+
+            SDL_Rect src;
+            src.x = (int)floorf(min_u * tex_w + 0.5f);
+            src.y = (int)floorf(min_v * tex_h + 0.5f);
+            src.w = (int)floorf((max_u - min_u) * tex_w + 0.5f);
+            src.h = (int)floorf((max_v - min_v) * tex_h + 0.5f);
+            if (src.w < 1) src.w = 1;
+            if (src.h < 1) src.h = 1;
+
+            /* Use first vertex color as approximation */
+            SDL_SetTextureColorMod(texture, v0->col[0], v0->col[1], v0->col[2]);
+            SDL_SetTextureAlphaMod(texture, v0->col[3]);
+            SDL_SetTextureBlendMode(texture, SDL_BLENDMODE_BLEND);
+            SDL_RenderCopy(renderer, texture, &src, &dst);
+        }
+        else
+        {
+            /* For solid color triangles, just fill the bounding box */
+            SDL_Rect dst;
+            dst.x = (int)floorf(min_x + 0.5f);
+            dst.y = (int)floorf(min_y + 0.5f);
+            dst.w = (int)floorf(max_x - min_x + 0.5f);
+            dst.h = (int)floorf(max_y - min_y + 0.5f);
+            if (dst.w < 1) dst.w = 1;
+            if (dst.h < 1) dst.h = 1;
+
+            SDL_SetRenderDrawBlendMode(renderer, SDL_BLENDMODE_BLEND);
+            SDL_SetRenderDrawColor(renderer, v0->col[0], v0->col[1], v0->col[2], v0->col[3]);
+            SDL_RenderFillRect(renderer, &dst);
+        }
+
+        processed += indices_per_tri;
+    }
+#endif /* !SDL_VERSION_ATLEAST(2, 0, 18) */
+}

 NK_INTERN void
 nk_sdl_device_upload_atlas(const void *image, int width, int height)
 {
     struct nk_sdl_device *dev = &sdl.ogl;

-    SDL_Texture *g_SDLFontTexture = SDL_CreateTexture(sdl.renderer, SDL_PIXELFORMAT_ARGB8888, SDL_TEXTUREACCESS_STATIC, width, height);
+    SDL_Texture *g_SDLFontTexture = NULL;
+#if !SDL_VERSION_ATLEAST(2, 0, 12)
+    const char *prev_scale_hint = SDL_GetHint(SDL_HINT_RENDER_SCALE_QUALITY);
+    char *prev_scale_copy = prev_scale_hint ? SDL_strdup(prev_scale_hint) : NULL;
+    SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "1");
+#endif
+
+    g_SDLFontTexture = SDL_CreateTexture(sdl.renderer, SDL_PIXELFORMAT_ARGB8888, SDL_TEXTUREACCESS_STATIC, width, height);
     if (g_SDLFontTexture == NULL) {
+#if !SDL_VERSION_ATLEAST(2, 0, 12)
+        SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, prev_scale_copy);
+        if (prev_scale_copy)
+            SDL_free(prev_scale_copy);
+#endif
         SDL_Log("error creating texture");
         return;
     }
+#if SDL_VERSION_ATLEAST(2, 0, 12)
+    SDL_SetTextureScaleMode(g_SDLFontTexture, SDL_ScaleModeLinear);
+#else
+    SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, prev_scale_copy);
+    if (prev_scale_copy)
+        SDL_free(prev_scale_copy);
+#endif
     SDL_UpdateTexture(g_SDLFontTexture, NULL, image, 4 * width);
     SDL_SetTextureBlendMode(g_SDLFontTexture, SDL_BLENDMODE_BLEND);
     dev->font_tex = g_SDLFontTexture;
@@ -95,9 +300,11 @@ nk_sdl_render(enum nk_anti_aliasing AA)
 #endif
         SDL_bool clipping_enabled;
         int vs = sizeof(struct nk_sdl_vertex);
+#if SDL_VERSION_ATLEAST(2, 0, 18)
         size_t vp = offsetof(struct nk_sdl_vertex, position);
         size_t vt = offsetof(struct nk_sdl_vertex, uv);
         size_t vc = offsetof(struct nk_sdl_vertex, col);
+#endif

         /* convert from command queue into draw list and draw to screen */
         const struct nk_draw_command *cmd;
@@ -113,7 +320,7 @@ nk_sdl_render(enum nk_anti_aliasing AA)
             {NK_VERTEX_LAYOUT_END}
         };

-        Uint64 now = SDL_GetTicks64();
+        Uint64 now = nk_sdl_get_ticks();
         sdl.ctx.delta_time_seconds = (float)(now - sdl.time_of_last_frame) / 1000;
         sdl.time_of_last_frame = now;

@@ -175,6 +382,7 @@ nk_sdl_render(enum nk_anti_aliasing AA)
             {
                 const void *vertices = nk_buffer_memory_const(&vbuf);

+#if SDL_VERSION_ATLEAST(2, 0, 18)
                 SDL_RenderGeometryRaw(sdl.renderer,
                         (SDL_Texture *)cmd->texture.ptr,
                         (const float*)((const nk_byte*)vertices + vp), vs,
@@ -182,6 +390,14 @@ nk_sdl_render(enum nk_anti_aliasing AA)
                         (const float*)((const nk_byte*)vertices + vt), vs,
                         (vbuf.needed / vs),
                         (void *) offset, cmd->elem_count, 2);
+#else
+                nk_sdl_render_geometry_raw_legacy(sdl.renderer,
+                        (SDL_Texture *)cmd->texture.ptr,
+                        vertices,
+                        vs,
+                        offset,
+                        cmd->elem_count);
+#endif

                 offset += cmd->elem_count;
             }
@@ -248,7 +464,14 @@ nk_sdl_init(SDL_Window *win, SDL_Renderer *renderer)
 #endif
     sdl.win = win;
     sdl.renderer = renderer;
-    sdl.time_of_last_frame = SDL_GetTicks64();
+    sdl.time_of_last_frame = nk_sdl_get_ticks();
+    {
+        const char *debug_env = SDL_getenv("NUKLEAR_LEGACY_DEBUG");
+        nk_sdl_debug_logging = (debug_env && debug_env[0] != '\0' && debug_env[0] != '0') ? SDL_TRUE : SDL_FALSE;
+    }
+    if (nk_sdl_debug_logging) {
+        printf("NK legacy renderer debug logging enabled\n");
+    }
     nk_init_default(&sdl.ctx, 0);
     sdl.ctx.clip.copy = nk_sdl_clipboard_copy;
     sdl.ctx.clip.paste = nk_sdl_clipboard_paste;
@@ -382,7 +605,11 @@ nk_sdl_handle_event(SDL_Event *evt)
             return 1;

         case SDL_MOUSEWHEEL:
-            nk_input_scroll(ctx,nk_vec2(evt->wheel.preciseX, evt->wheel.preciseY));
+#if SDL_VERSION_ATLEAST(2, 0, 18)
+            nk_input_scroll(ctx, nk_vec2(evt->wheel.preciseX, evt->wheel.preciseY));
+#else
+            nk_input_scroll(ctx, nk_vec2((float)evt->wheel.x, (float)evt->wheel.y));
+#endif
             return 1;
     }
     return 0;
