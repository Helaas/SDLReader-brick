--- demo/sdl_renderer/nuklear_sdl_renderer.h.orig
+++ demo/sdl_renderer/nuklear_sdl_renderer.h
@@ -15,13 +15,13 @@
 #define NK_SDL_RENDERER_SDL_H <SDL.h>
 #endif
 #include NK_SDL_RENDERER_SDL_H
-NK_API struct nk_context*   nk_sdl_init(SDL_Window *win, SDL_Renderer *renderer);
-NK_API void                 nk_sdl_font_stash_begin(struct nk_font_atlas **atlas);
-NK_API void                 nk_sdl_font_stash_end(void);
-NK_API int                  nk_sdl_handle_event(SDL_Event *evt);
-NK_API void                 nk_sdl_render(enum nk_anti_aliasing);
-NK_API void                 nk_sdl_shutdown(void);
-NK_API void                 nk_sdl_handle_grab(void);
+NK_API struct nk_context* nk_sdl_init(SDL_Window* win, SDL_Renderer* renderer);
+NK_API void nk_sdl_font_stash_begin(struct nk_font_atlas** atlas);
+NK_API void nk_sdl_font_stash_end(void);
+NK_API int nk_sdl_handle_event(SDL_Event* evt);
+NK_API void nk_sdl_render(enum nk_anti_aliasing);
+NK_API void nk_sdl_shutdown(void);
+NK_API void nk_sdl_handle_grab(void);
 
 #if SDL_COMPILEDVERSION < SDL_VERSIONNUM(2, 0, 22)
 /* Metal API does not support cliprects with negative coordinates or large
@@ -43,37 +43,202 @@
  * ===============================================================
  */
 #ifdef NK_SDL_RENDERER_IMPLEMENTATION
-#include <string.h>
 #include <stdlib.h>
+#include <string.h>
+#include <math.h>
 
-struct nk_sdl_device {
+struct nk_sdl_device
+{
     struct nk_buffer cmds;
     struct nk_draw_null_texture tex_null;
-    SDL_Texture *font_tex;
+    SDL_Texture* font_tex;
 };
 
-struct nk_sdl_vertex {
+struct nk_sdl_vertex
+{
     float position[2];
     float uv[2];
     nk_byte col[4];
 };
 
-static struct nk_sdl {
-    SDL_Window *win;
-    SDL_Renderer *renderer;
+static struct nk_sdl
+{
+    SDL_Window* win;
+    SDL_Renderer* renderer;
     struct nk_sdl_device ogl;
     struct nk_context ctx;
     struct nk_font_atlas atlas;
     Uint64 time_of_last_frame;
 } sdl;
 
+static inline Uint64
+nk_sdl_get_ticks(void)
+{
+#if SDL_VERSION_ATLEAST(2, 0, 18)
+    return SDL_GetTicks64();
+#else
+    return (Uint64) SDL_GetTicks();
+#endif
+}
+
+#if !SDL_VERSION_ATLEAST(2, 0, 18)
+static inline float
+nk_sdl_minf(float a, float b)
+{
+    return (a < b) ? a : b;
+}
+
+static inline float
+nk_sdl_maxf(float a, float b)
+{
+    return (a > b) ? a : b;
+}
+
+static inline int
+nk_sdl_maxi(int a, int b)
+{
+    return (a > b) ? a : b;
+}
+
+static void
+nk_sdl_render_geometry_raw_legacy(SDL_Renderer* renderer,
+                                  SDL_Texture* texture,
+                                  const void* vertices_base,
+                                  int vertex_stride,
+                                  const nk_draw_index* indices,
+                                  int elem_count)
+{
+    if (!renderer || !vertices_base || !indices || elem_count <= 0)
+        return;
+
+    const nk_byte* vertex_bytes = (const nk_byte*) vertices_base;
+
+    int tex_w = 0;
+    int tex_h = 0;
+    if (texture)
+    {
+        SDL_QueryTexture(texture, NULL, NULL, &tex_w, &tex_h);
+    }
+
+    Uint8 base_r = 255, base_g = 255, base_b = 255, base_a = 255;
+    if (texture)
+    {
+        SDL_GetTextureColorMod(texture, &base_r, &base_g, &base_b);
+        SDL_GetTextureAlphaMod(texture, &base_a);
+    }
+
+    const int indices_per_quad = 6;
+    int processed = 0;
+
+    while (processed + indices_per_quad <= elem_count)
+    {
+        const nk_draw_index* idx = indices + processed;
+
+        nk_draw_index unique_indices[4];
+        int unique_count = 0;
+        for (int j = 0; j < indices_per_quad && unique_count < 4; ++j)
+        {
+            nk_draw_index value = idx[j];
+            int exists = 0;
+            for (int k = 0; k < unique_count; ++k)
+            {
+                if (unique_indices[k] == value)
+                {
+                    exists = 1;
+                    break;
+                }
+            }
+            if (!exists)
+            {
+                unique_indices[unique_count++] = value;
+            }
+        }
+
+        if (unique_count < 4)
+        {
+            processed += indices_per_quad;
+            continue;
+        }
+
+        const struct nk_sdl_vertex* verts[4];
+        for (int k = 0; k < 4; ++k)
+        {
+            verts[k] = (const struct nk_sdl_vertex*) (vertex_bytes + vertex_stride * unique_indices[k]);
+        }
+
+        float min_x = verts[0]->position[0];
+        float max_x = min_x;
+        float min_y = verts[0]->position[1];
+        float max_y = min_y;
+        float min_u = verts[0]->uv[0];
+        float max_u = min_u;
+        float min_v = verts[0]->uv[1];
+        float max_v = min_v;
+
+        for (int k = 1; k < 4; ++k)
+        {
+            min_x = nk_sdl_minf(min_x, verts[k]->position[0]);
+            max_x = nk_sdl_maxf(max_x, verts[k]->position[0]);
+            min_y = nk_sdl_minf(min_y, verts[k]->position[1]);
+            max_y = nk_sdl_maxf(max_y, verts[k]->position[1]);
+            min_u = nk_sdl_minf(min_u, verts[k]->uv[0]);
+            max_u = nk_sdl_maxf(max_u, verts[k]->uv[0]);
+            min_v = nk_sdl_minf(min_v, verts[k]->uv[1]);
+            max_v = nk_sdl_maxf(max_v, verts[k]->uv[1]);
+        }
+
+        if ((max_x - min_x) <= 0.0f || (max_y - min_y) <= 0.0f)
+        {
+            processed += indices_per_quad;
+            continue;
+        }
+
+        SDL_Rect dst;
+        dst.x = (int) floorf(min_x + 0.5f);
+        dst.y = (int) floorf(min_y + 0.5f);
+    dst.w = nk_sdl_maxi(1, (int) floorf((max_x - min_x) + 0.5f));
+    dst.h = nk_sdl_maxi(1, (int) floorf((max_y - min_y) + 0.5f));
+
+        SDL_Color color = {verts[0]->col[0], verts[0]->col[1], verts[0]->col[2], verts[0]->col[3]};
+
+        if (texture && tex_w > 0 && tex_h > 0)
+        {
+            SDL_Rect src;
+            src.x = (int) floorf(min_u * tex_w + 0.5f);
+            src.y = (int) floorf(min_v * tex_h + 0.5f);
+            src.w = nk_sdl_maxi(1, (int) floorf((max_u - min_u) * tex_w + 0.5f));
+            src.h = nk_sdl_maxi(1, (int) floorf((max_v - min_v) * tex_h + 0.5f));
+
+            SDL_SetTextureColorMod(texture, color.r, color.g, color.b);
+            SDL_SetTextureAlphaMod(texture, color.a);
+            SDL_RenderCopy(renderer, texture, &src, &dst);
+        }
+        else
+        {
+            SDL_SetRenderDrawBlendMode(renderer, SDL_BLENDMODE_BLEND);
+            SDL_SetRenderDrawColor(renderer, color.r, color.g, color.b, color.a);
+            SDL_RenderFillRect(renderer, &dst);
+        }
+
+        processed += indices_per_quad;
+    }
+
+    if (texture)
+    {
+        SDL_SetTextureColorMod(texture, base_r, base_g, base_b);
+        SDL_SetTextureAlphaMod(texture, base_a);
+    }
+}
+#endif /* !SDL_VERSION_ATLEAST(2, 0, 18) */
+
 NK_INTERN void
-nk_sdl_device_upload_atlas(const void *image, int width, int height)
+nk_sdl_device_upload_atlas(const void* image, int width, int height)
 {
-    struct nk_sdl_device *dev = &sdl.ogl;
+    struct nk_sdl_device* dev = &sdl.ogl;
 
-    SDL_Texture *g_SDLFontTexture = SDL_CreateTexture(sdl.renderer, SDL_PIXELFORMAT_ARGB8888, SDL_TEXTUREACCESS_STATIC, width, height);
-    if (g_SDLFontTexture == NULL) {
+    SDL_Texture* g_SDLFontTexture = SDL_CreateTexture(sdl.renderer, SDL_PIXELFORMAT_ARGB8888, SDL_TEXTUREACCESS_STATIC, width, height);
+    if (g_SDLFontTexture == NULL)
+    {
         SDL_Log("error creating texture");
         return;
     }
@@ -86,7 +251,7 @@
 nk_sdl_render(enum nk_anti_aliasing AA)
 {
     /* setup global state */
-    struct nk_sdl_device *dev = &sdl.ogl;
+    struct nk_sdl_device* dev = &sdl.ogl;
 
     {
         SDL_Rect saved_clip;
@@ -100,8 +265,8 @@
         size_t vc = offsetof(struct nk_sdl_vertex, col);
 
         /* convert from command queue into draw list and draw to screen */
-        const struct nk_draw_command *cmd;
-        const nk_draw_index *offset = NULL;
+        const struct nk_draw_command* cmd;
+        const nk_draw_index* offset = NULL;
         struct nk_buffer vbuf, ebuf;
 
         /* fill converting configuration */
@@ -110,11 +275,10 @@
             {NK_VERTEX_POSITION, NK_FORMAT_FLOAT, NK_OFFSETOF(struct nk_sdl_vertex, position)},
             {NK_VERTEX_TEXCOORD, NK_FORMAT_FLOAT, NK_OFFSETOF(struct nk_sdl_vertex, uv)},
             {NK_VERTEX_COLOR, NK_FORMAT_R8G8B8A8, NK_OFFSETOF(struct nk_sdl_vertex, col)},
-            {NK_VERTEX_LAYOUT_END}
-        };
+            {NK_VERTEX_LAYOUT_END}};
 
-        Uint64 now = SDL_GetTicks64();
-        sdl.ctx.delta_time_seconds = (float)(now - sdl.time_of_last_frame) / 1000;
+    Uint64 now = nk_sdl_get_ticks();
+        sdl.ctx.delta_time_seconds = (float) (now - sdl.time_of_last_frame) / 1000;
         sdl.time_of_last_frame = now;
 
         NK_MEMSET(&config, 0, sizeof(config));
@@ -135,7 +299,7 @@
         nk_convert(&sdl.ctx, &dev->cmds, &vbuf, &ebuf, &config);
 
         /* iterate over and execute each draw command */
-        offset = (const nk_draw_index*)nk_buffer_memory_const(&ebuf);
+        offset = (const nk_draw_index*) nk_buffer_memory_const(&ebuf);
 
         clipping_enabled = SDL_RenderIsClipEnabled(sdl.renderer);
         SDL_RenderGetClipRect(sdl.renderer, &saved_clip);
@@ -145,7 +309,8 @@
 
         nk_draw_foreach(cmd, &sdl.ctx, &dev->cmds)
         {
-            if (!cmd->elem_count) continue;
+            if (!cmd->elem_count)
+                continue;
 
             {
                 SDL_Rect r;
@@ -154,18 +319,22 @@
                 r.w = cmd->clip_rect.w;
                 r.h = cmd->clip_rect.h;
 #ifdef NK_SDL_CLAMP_CLIP_RECT
-                if (r.x < 0) {
+                if (r.x < 0)
+                {
                     r.w += r.x;
                     r.x = 0;
                 }
-                if (r.y < 0) {
+                if (r.y < 0)
+                {
                     r.h += r.y;
                     r.y = 0;
                 }
-                if (r.h > viewport.h) {
+                if (r.h > viewport.h)
+                {
                     r.h = viewport.h;
                 }
-                if (r.w > viewport.w) {
+                if (r.w > viewport.w)
+                {
                     r.w = viewport.w;
                 }
 #endif
@@ -173,22 +342,32 @@
             }
 
             {
-                const void *vertices = nk_buffer_memory_const(&vbuf);
+                const void* vertices = nk_buffer_memory_const(&vbuf);
 
+#if SDL_VERSION_ATLEAST(2, 0, 18)
                 SDL_RenderGeometryRaw(sdl.renderer,
-                        (SDL_Texture *)cmd->texture.ptr,
-                        (const float*)((const nk_byte*)vertices + vp), vs,
-                        (const SDL_Color*)((const nk_byte*)vertices + vc), vs,
-                        (const float*)((const nk_byte*)vertices + vt), vs,
-                        (vbuf.needed / vs),
-                        (void *) offset, cmd->elem_count, 2);
+                                      (SDL_Texture*) cmd->texture.ptr,
+                                      (const float*) ((const nk_byte*) vertices + vp), vs,
+                                      (const SDL_Color*) ((const nk_byte*) vertices + vc), vs,
+                                      (const float*) ((const nk_byte*) vertices + vt), vs,
+                                      (vbuf.needed / vs),
+                                      (void*) offset, cmd->elem_count, 2);
+#else
+                nk_sdl_render_geometry_raw_legacy(sdl.renderer,
+                                                  (SDL_Texture*) cmd->texture.ptr,
+                                                  vertices,
+                                                  vs,
+                                                  offset,
+                                                  cmd->elem_count);
+#endif
 
                 offset += cmd->elem_count;
             }
         }
 
         SDL_RenderSetClipRect(sdl.renderer, &saved_clip);
-        if (!clipping_enabled) {
+        if (!clipping_enabled)
+        {
             SDL_RenderSetClipRect(sdl.renderer, NULL);
         }
 
@@ -200,29 +379,32 @@
 }
 
 static void
-nk_sdl_clipboard_paste(nk_handle usr, struct nk_text_edit *edit)
+nk_sdl_clipboard_paste(nk_handle usr, struct nk_text_edit* edit)
 {
-    const char *text = SDL_GetClipboardText();
-    if (text) nk_textedit_paste(edit, text, nk_strlen(text));
-    (void)usr;
+    const char* text = SDL_GetClipboardText();
+    if (text)
+        nk_textedit_paste(edit, text, nk_strlen(text));
+    (void) usr;
 }
 
 static void
-nk_sdl_clipboard_copy(nk_handle usr, const char *text, int len)
+nk_sdl_clipboard_copy(nk_handle usr, const char* text, int len)
 {
-    char *str = 0;
-    (void)usr;
-    if (!len) return;
-    str = (char*)malloc((size_t)len+1);
-    if (!str) return;
-    memcpy(str, text, (size_t)len);
+    char* str = 0;
+    (void) usr;
+    if (!len)
+        return;
+    str = (char*) malloc((size_t) len + 1);
+    if (!str)
+        return;
+    memcpy(str, text, (size_t) len);
     str[len] = '\0';
     SDL_SetClipboardText(str);
     free(str);
 }
 
 NK_API struct nk_context*
-nk_sdl_init(SDL_Window *win, SDL_Renderer *renderer)
+nk_sdl_init(SDL_Window* win, SDL_Renderer* renderer)
 {
 #ifndef NK_SDL_CLAMP_CLIP_RECT
     SDL_RendererInfo info;
@@ -239,13 +421,12 @@
             "renderer is using Metal API but runtime SDL version %d.%d.%d is older than compiled version %d.%d.%d, "
             "which may cause issues with rendering",
             runtimeVer.major, runtimeVer.minor, runtimeVer.patch,
-            SDL_MAJOR_VERSION, SDL_MINOR_VERSION, SDL_PATCHLEVEL
-        );
+            SDL_MAJOR_VERSION, SDL_MINOR_VERSION, SDL_PATCHLEVEL);
     }
 #endif
     sdl.win = win;
     sdl.renderer = renderer;
-    sdl.time_of_last_frame = SDL_GetTicks64();
+    sdl.time_of_last_frame = nk_sdl_get_ticks();
     nk_init_default(&sdl.ctx, 0);
     sdl.ctx.clip.copy = nk_sdl_clipboard_copy;
     sdl.ctx.clip.paste = nk_sdl_clipboard_paste;
@@ -255,7 +436,7 @@
 }
 
 NK_API void
-nk_sdl_font_stash_begin(struct nk_font_atlas **atlas)
+nk_sdl_font_stash_begin(struct nk_font_atlas** atlas)
 {
     nk_font_atlas_init_default(&sdl.atlas);
     nk_font_atlas_begin(&sdl.atlas);
@@ -265,7 +446,8 @@
 NK_API void
 nk_sdl_font_stash_end(void)
 {
-    const void *image; int w, h;
+    const void* image;
+    int w, h;
     image = nk_font_atlas_bake(&sdl.atlas, &w, &h, NK_FONT_ATLAS_RGBA32);
     nk_sdl_device_upload_atlas(image, w, h);
     nk_font_atlas_end(&sdl.atlas, nk_handle_ptr(sdl.ogl.font_tex), &sdl.ogl.tex_null);
@@ -276,104 +458,154 @@
 NK_API void
 nk_sdl_handle_grab(void)
 {
-    struct nk_context *ctx = &sdl.ctx;
-    if (ctx->input.mouse.grab) {
+    struct nk_context* ctx = &sdl.ctx;
+    if (ctx->input.mouse.grab)
+    {
         SDL_SetRelativeMouseMode(SDL_TRUE);
-    } else if (ctx->input.mouse.ungrab) {
+    }
+    else if (ctx->input.mouse.ungrab)
+    {
         /* better support for older SDL by setting mode first; causes an extra mouse motion event */
         SDL_SetRelativeMouseMode(SDL_FALSE);
-        SDL_WarpMouseInWindow(sdl.win, (int)ctx->input.mouse.prev.x, (int)ctx->input.mouse.prev.y);
-    } else if (ctx->input.mouse.grabbed) {
+        SDL_WarpMouseInWindow(sdl.win, (int) ctx->input.mouse.prev.x, (int) ctx->input.mouse.prev.y);
+    }
+    else if (ctx->input.mouse.grabbed)
+    {
         ctx->input.mouse.pos.x = ctx->input.mouse.prev.x;
         ctx->input.mouse.pos.y = ctx->input.mouse.prev.y;
     }
 }
 
 NK_API int
-nk_sdl_handle_event(SDL_Event *evt)
+nk_sdl_handle_event(SDL_Event* evt)
 {
-    struct nk_context *ctx = &sdl.ctx;
+    struct nk_context* ctx = &sdl.ctx;
 
-    switch(evt->type)
+    switch (evt->type)
     {
-        case SDL_KEYUP: /* KEYUP & KEYDOWN share same routine */
-        case SDL_KEYDOWN:
-            {
-                int down = evt->type == SDL_KEYDOWN;
-                const Uint8* state = SDL_GetKeyboardState(0);
-                switch(evt->key.keysym.sym)
-                {
-                    case SDLK_RSHIFT: /* RSHIFT & LSHIFT share same routine */
-                    case SDLK_LSHIFT:    nk_input_key(ctx, NK_KEY_SHIFT, down); break;
-                    case SDLK_DELETE:    nk_input_key(ctx, NK_KEY_DEL, down); break;
-                    case SDLK_RETURN:    nk_input_key(ctx, NK_KEY_ENTER, down); break;
-                    case SDLK_TAB:       nk_input_key(ctx, NK_KEY_TAB, down); break;
-                    case SDLK_BACKSPACE: nk_input_key(ctx, NK_KEY_BACKSPACE, down); break;
-                    case SDLK_HOME:      nk_input_key(ctx, NK_KEY_TEXT_START, down);
-                                         nk_input_key(ctx, NK_KEY_SCROLL_START, down); break;
-                    case SDLK_END:       nk_input_key(ctx, NK_KEY_TEXT_END, down);
-                                         nk_input_key(ctx, NK_KEY_SCROLL_END, down); break;
-                    case SDLK_PAGEDOWN:  nk_input_key(ctx, NK_KEY_SCROLL_DOWN, down); break;
-                    case SDLK_PAGEUP:    nk_input_key(ctx, NK_KEY_SCROLL_UP, down); break;
-                    case SDLK_z:         nk_input_key(ctx, NK_KEY_TEXT_UNDO, down && state[SDL_SCANCODE_LCTRL]); break;
-                    case SDLK_r:         nk_input_key(ctx, NK_KEY_TEXT_REDO, down && state[SDL_SCANCODE_LCTRL]); break;
-                    case SDLK_c:         nk_input_key(ctx, NK_KEY_COPY, down && state[SDL_SCANCODE_LCTRL]); break;
-                    case SDLK_v:         nk_input_key(ctx, NK_KEY_PASTE, down && state[SDL_SCANCODE_LCTRL]); break;
-                    case SDLK_x:         nk_input_key(ctx, NK_KEY_CUT, down && state[SDL_SCANCODE_LCTRL]); break;
-                    case SDLK_b:         nk_input_key(ctx, NK_KEY_TEXT_LINE_START, down && state[SDL_SCANCODE_LCTRL]); break;
-                    case SDLK_e:         nk_input_key(ctx, NK_KEY_TEXT_LINE_END, down && state[SDL_SCANCODE_LCTRL]); break;
-                    case SDLK_UP:        nk_input_key(ctx, NK_KEY_UP, down); break;
-                    case SDLK_DOWN:      nk_input_key(ctx, NK_KEY_DOWN, down); break;
-                    case SDLK_LEFT:
-                        if (state[SDL_SCANCODE_LCTRL])
-                            nk_input_key(ctx, NK_KEY_TEXT_WORD_LEFT, down);
-                        else nk_input_key(ctx, NK_KEY_LEFT, down);
-                        break;
-                    case SDLK_RIGHT:
-                        if (state[SDL_SCANCODE_LCTRL])
-                            nk_input_key(ctx, NK_KEY_TEXT_WORD_RIGHT, down);
-                        else nk_input_key(ctx, NK_KEY_RIGHT, down);
-                        break;
-                }
-            }
-            return 1;
+    case SDL_KEYUP: /* KEYUP & KEYDOWN share same routine */
+    case SDL_KEYDOWN:
+    {
+        int down = evt->type == SDL_KEYDOWN;
+        const Uint8* state = SDL_GetKeyboardState(0);
+        switch (evt->key.keysym.sym)
+        {
+        case SDLK_RSHIFT: /* RSHIFT & LSHIFT share same routine */
+        case SDLK_LSHIFT:
+            nk_input_key(ctx, NK_KEY_SHIFT, down);
+            break;
+        case SDLK_DELETE:
+            nk_input_key(ctx, NK_KEY_DEL, down);
+            break;
+        case SDLK_RETURN:
+            nk_input_key(ctx, NK_KEY_ENTER, down);
+            break;
+        case SDLK_TAB:
+            nk_input_key(ctx, NK_KEY_TAB, down);
+            break;
+        case SDLK_BACKSPACE:
+            nk_input_key(ctx, NK_KEY_BACKSPACE, down);
+            break;
+        case SDLK_HOME:
+            nk_input_key(ctx, NK_KEY_TEXT_START, down);
+            nk_input_key(ctx, NK_KEY_SCROLL_START, down);
+            break;
+        case SDLK_END:
+            nk_input_key(ctx, NK_KEY_TEXT_END, down);
+            nk_input_key(ctx, NK_KEY_SCROLL_END, down);
+            break;
+        case SDLK_PAGEDOWN:
+            nk_input_key(ctx, NK_KEY_SCROLL_DOWN, down);
+            break;
+        case SDLK_PAGEUP:
+            nk_input_key(ctx, NK_KEY_SCROLL_UP, down);
+            break;
+        case SDLK_z:
+            nk_input_key(ctx, NK_KEY_TEXT_UNDO, down && state[SDL_SCANCODE_LCTRL]);
+            break;
+        case SDLK_r:
+            nk_input_key(ctx, NK_KEY_TEXT_REDO, down && state[SDL_SCANCODE_LCTRL]);
+            break;
+        case SDLK_c:
+            nk_input_key(ctx, NK_KEY_COPY, down && state[SDL_SCANCODE_LCTRL]);
+            break;
+        case SDLK_v:
+            nk_input_key(ctx, NK_KEY_PASTE, down && state[SDL_SCANCODE_LCTRL]);
+            break;
+        case SDLK_x:
+            nk_input_key(ctx, NK_KEY_CUT, down && state[SDL_SCANCODE_LCTRL]);
+            break;
+        case SDLK_b:
+            nk_input_key(ctx, NK_KEY_TEXT_LINE_START, down && state[SDL_SCANCODE_LCTRL]);
+            break;
+        case SDLK_e:
+            nk_input_key(ctx, NK_KEY_TEXT_LINE_END, down && state[SDL_SCANCODE_LCTRL]);
+            break;
+        case SDLK_UP:
+            nk_input_key(ctx, NK_KEY_UP, down);
+            break;
+        case SDLK_DOWN:
+            nk_input_key(ctx, NK_KEY_DOWN, down);
+            break;
+        case SDLK_LEFT:
+            if (state[SDL_SCANCODE_LCTRL])
+                nk_input_key(ctx, NK_KEY_TEXT_WORD_LEFT, down);
+            else
+                nk_input_key(ctx, NK_KEY_LEFT, down);
+            break;
+        case SDLK_RIGHT:
+            if (state[SDL_SCANCODE_LCTRL])
+                nk_input_key(ctx, NK_KEY_TEXT_WORD_RIGHT, down);
+            else
+                nk_input_key(ctx, NK_KEY_RIGHT, down);
+            break;
+        }
+    }
+        return 1;
 
-        case SDL_MOUSEBUTTONUP: /* MOUSEBUTTONUP & MOUSEBUTTONDOWN share same routine */
-        case SDL_MOUSEBUTTONDOWN:
-            {
-                int down = evt->type == SDL_MOUSEBUTTONDOWN;
-                const int x = evt->button.x, y = evt->button.y;
-                switch(evt->button.button)
-                {
-                    case SDL_BUTTON_LEFT:
-                        if (evt->button.clicks > 1)
-                            nk_input_button(ctx, NK_BUTTON_DOUBLE, x, y, down);
-                        nk_input_button(ctx, NK_BUTTON_LEFT, x, y, down); break;
-                    case SDL_BUTTON_MIDDLE: nk_input_button(ctx, NK_BUTTON_MIDDLE, x, y, down); break;
-                    case SDL_BUTTON_RIGHT:  nk_input_button(ctx, NK_BUTTON_RIGHT, x, y, down); break;
-                }
-            }
-            return 1;
+    case SDL_MOUSEBUTTONUP: /* MOUSEBUTTONUP & MOUSEBUTTONDOWN share same routine */
+    case SDL_MOUSEBUTTONDOWN:
+    {
+        int down = evt->type == SDL_MOUSEBUTTONDOWN;
+        const int x = evt->button.x, y = evt->button.y;
+        switch (evt->button.button)
+        {
+        case SDL_BUTTON_LEFT:
+            if (evt->button.clicks > 1)
+                nk_input_button(ctx, NK_BUTTON_DOUBLE, x, y, down);
+            nk_input_button(ctx, NK_BUTTON_LEFT, x, y, down);
+            break;
+        case SDL_BUTTON_MIDDLE:
+            nk_input_button(ctx, NK_BUTTON_MIDDLE, x, y, down);
+            break;
+        case SDL_BUTTON_RIGHT:
+            nk_input_button(ctx, NK_BUTTON_RIGHT, x, y, down);
+            break;
+        }
+    }
+        return 1;
 
-        case SDL_MOUSEMOTION:
-            if (ctx->input.mouse.grabbed) {
-                int x = (int)ctx->input.mouse.prev.x, y = (int)ctx->input.mouse.prev.y;
-                nk_input_motion(ctx, x + evt->motion.xrel, y + evt->motion.yrel);
-            }
-            else nk_input_motion(ctx, evt->motion.x, evt->motion.y);
-            return 1;
+    case SDL_MOUSEMOTION:
+        if (ctx->input.mouse.grabbed)
+        {
+            int x = (int) ctx->input.mouse.prev.x, y = (int) ctx->input.mouse.prev.y;
+            nk_input_motion(ctx, x + evt->motion.xrel, y + evt->motion.yrel);
+        }
+        else
+            nk_input_motion(ctx, evt->motion.x, evt->motion.y);
+        return 1;
 
-        case SDL_TEXTINPUT:
-            {
-                nk_glyph glyph;
-                memcpy(glyph, evt->text.text, NK_UTF_SIZE);
-                nk_input_glyph(ctx, glyph);
-            }
-            return 1;
+    case SDL_TEXTINPUT:
+    {
+        nk_glyph glyph;
+        memcpy(glyph, evt->text.text, NK_UTF_SIZE);
+        nk_input_glyph(ctx, glyph);
+    }
+        return 1;
 
-        case SDL_MOUSEWHEEL:
-            nk_input_scroll(ctx,nk_vec2((float)evt->wheel.x,(float)evt->wheel.y));
-            return 1;
+    case SDL_MOUSEWHEEL:
+        nk_input_scroll(ctx, nk_vec2((float) evt->wheel.x, (float) evt->wheel.y));
+        return 1;
     }
     return 0;
 }
@@ -381,7 +613,7 @@
 NK_API
 void nk_sdl_shutdown(void)
 {
-    struct nk_sdl_device *dev = &sdl.ogl;
+    struct nk_sdl_device* dev = &sdl.ogl;
     nk_font_atlas_clear(&sdl.atlas);
     nk_free(&sdl.ctx);
     SDL_DestroyTexture(dev->font_tex);
