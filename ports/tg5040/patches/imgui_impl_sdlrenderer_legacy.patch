diff --git a/backends/imgui_impl_sdlrenderer.cpp b/backends/imgui_impl_sdlrenderer.cpp
index 87381f2..7a5183a 100644
--- a/backends/imgui_impl_sdlrenderer.cpp
+++ b/backends/imgui_impl_sdlrenderer.cpp
@@ -32,11 +32,14 @@
 #include <stdint.h>     // intptr_t
 #endif

+#include <algorithm>
+#include <cmath>
+#include <cstring>
+#include <vector>
+
 // SDL
 #include <SDL.h>
-#if !SDL_VERSION_ATLEAST(2,0,17)
-#error This backend requires SDL 2.0.17+ because of SDL_RenderGeometry() function
-#endif
+#if SDL_VERSION_ATLEAST(2,0,17)

 // SDL_Renderer data
 struct ImGui_ImplSDLRenderer_Data
@@ -249,3 +252,483 @@ void ImGui_ImplSDLRenderer_DestroyDeviceObjects()
 {
     ImGui_ImplSDLRenderer_DestroyFontsTexture();
 }
+#else
+
+struct ImGui_ImplSDLRenderer_Data
+{
+    SDL_Renderer* SDLRenderer;
+    SDL_Texture* FontTexture;
+    SDL_Texture* FrameTexture;
+    std::vector<ImU32> FontPixels;
+    int FontWidth;
+    int FontHeight;
+    std::vector<Uint32> Framebuffer;
+    int FrameWidth;
+    int FrameHeight;
+
+    ImGui_ImplSDLRenderer_Data()
+        : SDLRenderer(nullptr)
+        , FontTexture(nullptr)
+        , FrameTexture(nullptr)
+        , FontWidth(0)
+        , FontHeight(0)
+        , FrameWidth(0)
+        , FrameHeight(0)
+    {
+    }
+};
+
+static ImGui_ImplSDLRenderer_Data* ImGui_ImplSDLRenderer_GetBackendData()
+{
+    return ImGui::GetCurrentContext() ? (ImGui_ImplSDLRenderer_Data*)ImGui::GetIO().BackendRendererUserData : nullptr;
+}
+
+static void ImGui_ImplSDLRenderer_SetupRenderState()
+{
+    ImGui_ImplSDLRenderer_Data* bd = ImGui_ImplSDLRenderer_GetBackendData();
+    SDL_RenderSetViewport(bd->SDLRenderer, nullptr);
+    SDL_RenderSetClipRect(bd->SDLRenderer, nullptr);
+}
+
+static bool ImGui_ImplSDLRenderer_EnsureFramebuffer(ImGui_ImplSDLRenderer_Data* bd, int width, int height)
+{
+    if (width <= 0 || height <= 0)
+        return false;
+
+    if (bd->FrameWidth != width || bd->FrameHeight != height || bd->FrameTexture == nullptr)
+    {
+        if (bd->FrameTexture)
+        {
+            SDL_DestroyTexture(bd->FrameTexture);
+            bd->FrameTexture = nullptr;
+        }
+
+        bd->Framebuffer.resize((size_t)width * (size_t)height);
+        bd->FrameWidth = width;
+        bd->FrameHeight = height;
+
+        bd->FrameTexture = SDL_CreateTexture(bd->SDLRenderer, SDL_PIXELFORMAT_ABGR8888, SDL_TEXTUREACCESS_STREAMING, width, height);
+        if (bd->FrameTexture == nullptr)
+        {
+            SDL_Log("Failed to create ImGui legacy framebuffer: %s", SDL_GetError());
+            bd->Framebuffer.clear();
+            bd->FrameWidth = 0;
+            bd->FrameHeight = 0;
+            return false;
+        }
+
+        SDL_SetTextureBlendMode(bd->FrameTexture, SDL_BLENDMODE_BLEND);
+    }
+
+    std::fill(bd->Framebuffer.begin(), bd->Framebuffer.end(), 0u);
+    return true;
+}
+
+static ImVec4 ImGui_ImplSDLRenderer_UnpackColor(ImU32 col)
+{
+    const float inv255 = 1.0f / 255.0f;
+    return ImVec4(
+        ((col >> IM_COL32_R_SHIFT) & 0xFF) * inv255,
+        ((col >> IM_COL32_G_SHIFT) & 0xFF) * inv255,
+        ((col >> IM_COL32_B_SHIFT) & 0xFF) * inv255,
+        ((col >> IM_COL32_A_SHIFT) & 0xFF) * inv255);
+}
+
+static void ImGui_ImplSDLRenderer_SampleTexture(const ImGui_ImplSDLRenderer_Data* bd, SDL_Texture* texture,
+                                                float u, float v, float& out_r, float& out_g, float& out_b, float& out_a)
+{
+    if (texture == nullptr)
+    {
+        out_r = out_g = out_b = out_a = 1.0f;
+        return;
+    }
+
+    if (texture == bd->FontTexture && !bd->FontPixels.empty() && bd->FontWidth > 0 && bd->FontHeight > 0)
+    {
+        int x = (int)std::floor(u * bd->FontWidth);
+        int y = (int)std::floor(v * bd->FontHeight);
+        x = std::clamp(x, 0, bd->FontWidth - 1);
+        y = std::clamp(y, 0, bd->FontHeight - 1);
+
+        const size_t index = (size_t)y * (size_t)bd->FontWidth + (size_t)x;
+        ImU32 texel = bd->FontPixels[index];
+        const float inv255 = 1.0f / 255.0f;
+        out_r = ((texel >> IM_COL32_R_SHIFT) & 0xFF) * inv255;
+        out_g = ((texel >> IM_COL32_G_SHIFT) & 0xFF) * inv255;
+        out_b = ((texel >> IM_COL32_B_SHIFT) & 0xFF) * inv255;
+        out_a = ((texel >> IM_COL32_A_SHIFT) & 0xFF) * inv255;
+        return;
+    }
+
+    // Fallback: treat unknown textures as opaque white
+    out_r = out_g = out_b = out_a = 1.0f;
+}
+
+static void ImGui_ImplSDLRenderer_BlendPixel(ImGui_ImplSDLRenderer_Data* bd, int x, int y,
+                                             float src_r, float src_g, float src_b, float src_a)
+{
+    if (x < 0 || y < 0 || x >= bd->FrameWidth || y >= bd->FrameHeight)
+        return;
+
+    const size_t index = (size_t)y * (size_t)bd->FrameWidth + (size_t)x;
+    Uint32 dst = bd->Framebuffer[index];
+
+    int dst_r = (int)(dst & 0xFF);
+    int dst_g = (int)((dst >> 8) & 0xFF);
+    int dst_b = (int)((dst >> 16) & 0xFF);
+    int dst_a = (int)((dst >> 24) & 0xFF);
+
+    int src_a_i = (int)(src_a * 255.0f + 0.5f);
+    if (src_a_i <= 0)
+        return;
+    if (src_a_i > 255)
+        src_a_i = 255;
+
+    int src_r_i = (int)(src_r * 255.0f + 0.5f);
+    int src_g_i = (int)(src_g * 255.0f + 0.5f);
+    int src_b_i = (int)(src_b * 255.0f + 0.5f);
+
+    src_r_i = std::clamp(src_r_i, 0, 255);
+    src_g_i = std::clamp(src_g_i, 0, 255);
+    src_b_i = std::clamp(src_b_i, 0, 255);
+
+    int inv_a = 255 - src_a_i;
+
+    int out_r = (src_r_i * src_a_i + dst_r * inv_a + 127) / 255;
+    int out_g = (src_g_i * src_a_i + dst_g * inv_a + 127) / 255;
+    int out_b = (src_b_i * src_a_i + dst_b * inv_a + 127) / 255;
+    int out_a = src_a_i + (dst_a * inv_a + 127) / 255;
+
+    if (out_r > 255) out_r = 255;
+    if (out_g > 255) out_g = 255;
+    if (out_b > 255) out_b = 255;
+    if (out_a > 255) out_a = 255;
+
+    bd->Framebuffer[index] = (Uint32)(out_r & 0xFF)
+        | ((Uint32)(out_g & 0xFF) << 8)
+        | ((Uint32)(out_b & 0xFF) << 16)
+        | ((Uint32)(out_a & 0xFF) << 24);
+}
+
+static void ImGui_ImplSDLRenderer_RasterizeTriangle(
+    ImGui_ImplSDLRenderer_Data* bd,
+    const ImVec2& p0, const ImVec2& p1, const ImVec2& p2,
+    const ImVec2& uv0, const ImVec2& uv1, const ImVec2& uv2,
+    const ImVec4& c0, const ImVec4& c1, const ImVec4& c2,
+    SDL_Texture* texture, const SDL_Rect& clip_rect)
+{
+    float min_x = std::floor(std::min({p0.x, p1.x, p2.x}));
+    float max_x = std::ceil (std::max({p0.x, p1.x, p2.x}));
+    float min_y = std::floor(std::min({p0.y, p1.y, p2.y}));
+    float max_y = std::ceil (std::max({p0.y, p1.y, p2.y}));
+
+    int x0 = std::max((int)min_x, clip_rect.x);
+    int x1 = std::min((int)max_x, clip_rect.x + clip_rect.w - 1);
+    int y0 = std::max((int)min_y, clip_rect.y);
+    int y1 = std::min((int)max_y, clip_rect.y + clip_rect.h - 1);
+
+    if (x0 > x1 || y0 > y1)
+        return;
+
+    float area = (p1.y - p2.y) * (p0.x - p2.x) + (p2.x - p1.x) * (p0.y - p2.y);
+    if (fabsf(area) < 1e-6f)
+        return;
+    float inv_area = 1.0f / area;
+    bool area_positive = area > 0.0f;
+
+    for (int y = y0; y <= y1; ++y)
+    {
+        for (int x = x0; x <= x1; ++x)
+        {
+            float px = x + 0.5f;
+            float py = y + 0.5f;
+
+            float w0 = (p1.y - p2.y) * (px - p2.x) + (p2.x - p1.x) * (py - p2.y);
+            float w1 = (p2.y - p0.y) * (px - p2.x) + (p0.x - p2.x) * (py - p2.y);
+            float w2 = area - w0 - w1;
+
+            if (area_positive)
+            {
+                if (w0 < 0.0f || w1 < 0.0f || w2 < 0.0f)
+                    continue;
+            }
+            else
+            {
+                if (w0 > 0.0f || w1 > 0.0f || w2 > 0.0f)
+                    continue;
+            }
+
+            w0 *= inv_area;
+            w1 *= inv_area;
+            w2 *= inv_area;
+
+            ImVec4 color;
+            color.x = c0.x * w0 + c1.x * w1 + c2.x * w2;
+            color.y = c0.y * w0 + c1.y * w1 + c2.y * w2;
+            color.z = c0.z * w0 + c1.z * w1 + c2.z * w2;
+            color.w = c0.w * w0 + c1.w * w1 + c2.w * w2;
+
+            ImVec2 uv;
+            uv.x = uv0.x * w0 + uv1.x * w1 + uv2.x * w2;
+            uv.y = uv0.y * w0 + uv1.y * w1 + uv2.y * w2;
+
+            float tex_r, tex_g, tex_b, tex_a;
+            ImGui_ImplSDLRenderer_SampleTexture(bd, texture,
+                                                std::clamp(uv.x, 0.0f, 1.0f),
+                                                std::clamp(uv.y, 0.0f, 1.0f),
+                                                tex_r, tex_g, tex_b, tex_a);
+
+            float src_a = color.w * tex_a;
+            if (src_a <= 0.0f)
+                continue;
+
+            float src_r = color.x * tex_r;
+            float src_g = color.y * tex_g;
+            float src_b = color.z * tex_b;
+
+            ImGui_ImplSDLRenderer_BlendPixel(bd, x, y, src_r, src_g, src_b, src_a);
+        }
+    }
+}
+
+bool ImGui_ImplSDLRenderer_Init(SDL_Renderer* renderer)
+{
+    ImGuiIO& io = ImGui::GetIO();
+    IM_ASSERT(io.BackendRendererUserData == nullptr && "Already initialized a renderer backend!");
+    IM_ASSERT(renderer != nullptr && "SDL_Renderer not initialized!");
+
+    ImGui_ImplSDLRenderer_Data* bd = IM_NEW(ImGui_ImplSDLRenderer_Data)();
+    io.BackendRendererUserData = (void*)bd;
+    io.BackendRendererName = "imgui_impl_sdlrenderer_legacy";
+    io.BackendFlags |= ImGuiBackendFlags_RendererHasVtxOffset;
+
+    bd->SDLRenderer = renderer;
+
+    return true;
+}
+
+void ImGui_ImplSDLRenderer_Shutdown()
+{
+    ImGui_ImplSDLRenderer_Data* bd = ImGui_ImplSDLRenderer_GetBackendData();
+    if (bd == nullptr)
+        return;
+
+    ImGui_ImplSDLRenderer_DestroyDeviceObjects();
+
+    ImGuiIO& io = ImGui::GetIO();
+    io.BackendRendererName = nullptr;
+    io.BackendRendererUserData = nullptr;
+    IM_DELETE(bd);
+}
+
+void ImGui_ImplSDLRenderer_NewFrame()
+{
+    ImGui_ImplSDLRenderer_Data* bd = ImGui_ImplSDLRenderer_GetBackendData();
+    IM_ASSERT(bd != nullptr && "Did you call ImGui_ImplSDLRenderer_Init()?");
+
+    if (bd->FontTexture == nullptr)
+        ImGui_ImplSDLRenderer_CreateDeviceObjects();
+}
+
+void ImGui_ImplSDLRenderer_RenderDrawData(ImDrawData* draw_data)
+{
+    ImGui_ImplSDLRenderer_Data* bd = ImGui_ImplSDLRenderer_GetBackendData();
+    if (bd == nullptr)
+        return;
+
+    float renderer_scale_x = 1.0f;
+    float renderer_scale_y = 1.0f;
+    SDL_RenderGetScale(bd->SDLRenderer, &renderer_scale_x, &renderer_scale_y);
+
+    ImVec2 render_scale;
+    render_scale.x = (renderer_scale_x == 1.0f) ? draw_data->FramebufferScale.x : 1.0f;
+    render_scale.y = (renderer_scale_y == 1.0f) ? draw_data->FramebufferScale.y : 1.0f;
+
+    int fb_width = (int)(draw_data->DisplaySize.x * render_scale.x);
+    int fb_height = (int)(draw_data->DisplaySize.y * render_scale.y);
+    if (fb_width <= 0 || fb_height <= 0)
+        return;
+
+    if (!ImGui_ImplSDLRenderer_EnsureFramebuffer(bd, fb_width, fb_height))
+        return;
+
+    struct BackupSDLRendererState
+    {
+        SDL_Rect Viewport;
+        bool ClipEnabled;
+        SDL_Rect ClipRect;
+    };
+
+    BackupSDLRendererState old = {};
+    old.ClipEnabled = SDL_RenderIsClipEnabled(bd->SDLRenderer) == SDL_TRUE;
+    SDL_RenderGetViewport(bd->SDLRenderer, &old.Viewport);
+    SDL_RenderGetClipRect(bd->SDLRenderer, &old.ClipRect);
+
+    ImVec2 clip_off = draw_data->DisplayPos;
+    ImVec2 clip_scale = render_scale;
+
+    ImGui_ImplSDLRenderer_SetupRenderState();
+
+    for (int n = 0; n < draw_data->CmdListsCount; n++)
+    {
+        const ImDrawList* cmd_list = draw_data->CmdLists[n];
+        const ImDrawVert* vtx_buffer = cmd_list->VtxBuffer.Data;
+        const ImDrawIdx* idx_buffer = cmd_list->IdxBuffer.Data;
+
+        for (int cmd_i = 0; cmd_i < cmd_list->CmdBuffer.Size; cmd_i++)
+        {
+            const ImDrawCmd* pcmd = &cmd_list->CmdBuffer[cmd_i];
+            if (pcmd->UserCallback)
+            {
+                if (pcmd->UserCallback == ImDrawCallback_ResetRenderState)
+                    ImGui_ImplSDLRenderer_SetupRenderState();
+                else
+                    pcmd->UserCallback(cmd_list, pcmd);
+                continue;
+            }
+
+            ImVec2 clip_min = ImVec2((pcmd->ClipRect.x - clip_off.x) * clip_scale.x,
+                                     (pcmd->ClipRect.y - clip_off.y) * clip_scale.y);
+            ImVec2 clip_max = ImVec2((pcmd->ClipRect.z - clip_off.x) * clip_scale.x,
+                                     (pcmd->ClipRect.w - clip_off.y) * clip_scale.y);
+
+            if (clip_max.x <= clip_min.x || clip_max.y <= clip_min.y)
+                continue;
+
+            SDL_Rect clip_rect;
+            clip_rect.x = (int)std::floor(clip_min.x);
+            clip_rect.y = (int)std::floor(clip_min.y);
+            clip_rect.w = (int)std::ceil(clip_max.x - clip_min.x);
+            clip_rect.h = (int)std::ceil(clip_max.y - clip_min.y);
+
+            clip_rect.x = std::max(clip_rect.x, 0);
+            clip_rect.y = std::max(clip_rect.y, 0);
+            if (clip_rect.x + clip_rect.w > bd->FrameWidth)
+                clip_rect.w = bd->FrameWidth - clip_rect.x;
+            if (clip_rect.y + clip_rect.h > bd->FrameHeight)
+                clip_rect.h = bd->FrameHeight - clip_rect.y;
+
+            if (clip_rect.w <= 0 || clip_rect.h <= 0)
+                continue;
+
+            SDL_RenderSetClipRect(bd->SDLRenderer, &clip_rect);
+
+            SDL_Texture* texture = (SDL_Texture*)pcmd->GetTexID();
+
+            for (unsigned int idx = 0; idx < pcmd->ElemCount; idx += 3)
+            {
+                const unsigned int index0 = pcmd->VtxOffset + (unsigned int)idx_buffer[pcmd->IdxOffset + idx + 0];
+                const unsigned int index1 = pcmd->VtxOffset + (unsigned int)idx_buffer[pcmd->IdxOffset + idx + 1];
+                const unsigned int index2 = pcmd->VtxOffset + (unsigned int)idx_buffer[pcmd->IdxOffset + idx + 2];
+
+                const ImDrawVert& v0 = vtx_buffer[index0];
+                const ImDrawVert& v1 = vtx_buffer[index1];
+                const ImDrawVert& v2 = vtx_buffer[index2];
+
+                ImVec2 p0 = ImVec2((v0.pos.x - clip_off.x) * clip_scale.x, (v0.pos.y - clip_off.y) * clip_scale.y);
+                ImVec2 p1 = ImVec2((v1.pos.x - clip_off.x) * clip_scale.x, (v1.pos.y - clip_off.y) * clip_scale.y);
+                ImVec2 p2 = ImVec2((v2.pos.x - clip_off.x) * clip_scale.x, (v2.pos.y - clip_off.y) * clip_scale.y);
+
+                ImVec4 c0 = ImGui_ImplSDLRenderer_UnpackColor(v0.col);
+                ImVec4 c1 = ImGui_ImplSDLRenderer_UnpackColor(v1.col);
+                ImVec4 c2 = ImGui_ImplSDLRenderer_UnpackColor(v2.col);
+
+                ImGui_ImplSDLRenderer_RasterizeTriangle(bd, p0, p1, p2, v0.uv, v1.uv, v2.uv, c0, c1, c2, texture, clip_rect);
+            }
+        }
+    }
+
+    SDL_RenderSetViewport(bd->SDLRenderer, &old.Viewport);
+    SDL_RenderSetClipRect(bd->SDLRenderer, old.ClipEnabled ? &old.ClipRect : nullptr);
+
+    if (bd->FrameTexture)
+    {
+        SDL_UpdateTexture(bd->FrameTexture, nullptr, bd->Framebuffer.data(), bd->FrameWidth * (int)sizeof(Uint32));
+        SDL_RenderCopy(bd->SDLRenderer, bd->FrameTexture, nullptr, nullptr);
+    }
+}
+
+bool ImGui_ImplSDLRenderer_CreateFontsTexture()
+{
+    ImGuiIO& io = ImGui::GetIO();
+    ImGui_ImplSDLRenderer_Data* bd = ImGui_ImplSDLRenderer_GetBackendData();
+    IM_ASSERT(bd != nullptr);
+
+    unsigned char* pixels = nullptr;
+    int width = 0, height = 0;
+    io.Fonts->GetTexDataAsRGBA32(&pixels, &width, &height);
+    if (width <= 0 || height <= 0 || pixels == nullptr)
+        return false;
+
+    bd->FontPixels.resize((size_t)width * (size_t)height);
+    memcpy(bd->FontPixels.data(), pixels, (size_t)width * (size_t)height * sizeof(ImU32));
+    bd->FontWidth = width;
+    bd->FontHeight = height;
+
+    if (bd->FontTexture)
+    {
+        SDL_DestroyTexture(bd->FontTexture);
+        bd->FontTexture = nullptr;
+    }
+
+    bd->FontTexture = SDL_CreateTexture(bd->SDLRenderer, SDL_PIXELFORMAT_ABGR8888, SDL_TEXTUREACCESS_STATIC, width, height);
+    if (bd->FontTexture == nullptr)
+    {
+        SDL_Log("Failed to create font texture: %s", SDL_GetError());
+        bd->FontPixels.clear();
+        bd->FontWidth = 0;
+        bd->FontHeight = 0;
+        return false;
+    }
+
+    SDL_UpdateTexture(bd->FontTexture, nullptr, pixels, width * 4);
+    SDL_SetTextureBlendMode(bd->FontTexture, SDL_BLENDMODE_BLEND);
+
+    io.Fonts->SetTexID((ImTextureID)(intptr_t)bd->FontTexture);
+    return true;
+}
+
+void ImGui_ImplSDLRenderer_DestroyFontsTexture()
+{
+    ImGuiIO& io = ImGui::GetIO();
+    ImGui_ImplSDLRenderer_Data* bd = ImGui_ImplSDLRenderer_GetBackendData();
+    if (bd == nullptr)
+        return;
+
+    if (bd->FontTexture)
+    {
+        SDL_DestroyTexture(bd->FontTexture);
+        bd->FontTexture = nullptr;
+    }
+
+    bd->FontPixels.clear();
+    bd->FontWidth = 0;
+    bd->FontHeight = 0;
+    io.Fonts->SetTexID(nullptr);
+}
+
+bool ImGui_ImplSDLRenderer_CreateDeviceObjects()
+{
+    return ImGui_ImplSDLRenderer_CreateFontsTexture();
+}
+
+void ImGui_ImplSDLRenderer_DestroyDeviceObjects()
+{
+    ImGui_ImplSDLRenderer_Data* bd = ImGui_ImplSDLRenderer_GetBackendData();
+    if (bd == nullptr)
+        return;
+
+    ImGui_ImplSDLRenderer_DestroyFontsTexture();
+
+    if (bd->FrameTexture)
+    {
+        SDL_DestroyTexture(bd->FrameTexture);
+        bd->FrameTexture = nullptr;
+    }
+
+    bd->Framebuffer.clear();
+    bd->FrameWidth = 0;
+    bd->FrameHeight = 0;
+}
+
+#endif // SDL_VERSION_ATLEAST(2,0,17)
