diff --git a/backends/imgui_impl_sdlrenderer.cpp b/backends/imgui_impl_sdlrenderer.cpp
index 87381f2..a2529c0 100644
--- a/backends/imgui_impl_sdlrenderer.cpp
+++ b/backends/imgui_impl_sdlrenderer.cpp
@@ -24,33 +24,41 @@
 //  2021-10-06: Backup and restore modified ClipRect/Viewport.
 //  2021-09-21: Initial version.

-#include "imgui.h"
 #include "imgui_impl_sdlrenderer.h"
+#include "imgui.h"
 #if defined(_MSC_VER) && _MSC_VER <= 1500 // MSVC 2008 or earlier
-#include <stddef.h>     // intptr_t
+#include <stddef.h>                       // intptr_t
 #else
-#include <stdint.h>     // intptr_t
+#include <stdint.h> // intptr_t
 #endif

+#include <algorithm>
+#include <cmath>
+#include <cstdlib>
+#include <cstring>
+#include <unordered_map>
+#include <vector>
+
 // SDL
 #include <SDL.h>
-#if !SDL_VERSION_ATLEAST(2,0,17)
-#error This backend requires SDL 2.0.17+ because of SDL_RenderGeometry() function
-#endif
+#if SDL_VERSION_ATLEAST(2, 0, 17)

 // SDL_Renderer data
 struct ImGui_ImplSDLRenderer_Data
 {
-    SDL_Renderer*   SDLRenderer;
-    SDL_Texture*    FontTexture;
-    ImGui_ImplSDLRenderer_Data() { memset((void*)this, 0, sizeof(*this)); }
+    SDL_Renderer* SDLRenderer;
+    SDL_Texture* FontTexture;
+    ImGui_ImplSDLRenderer_Data()
+    {
+        memset((void*) this, 0, sizeof(*this));
+    }
 };

 // Backend data stored in io.BackendRendererUserData to allow support for multiple Dear ImGui contexts
 // It is STRONGLY preferred that you use docking branch with multi-viewports (== single Dear ImGui context + multiple windows) instead of multiple Dear ImGui contexts.
 static ImGui_ImplSDLRenderer_Data* ImGui_ImplSDLRenderer_GetBackendData()
 {
-    return ImGui::GetCurrentContext() ? (ImGui_ImplSDLRenderer_Data*)ImGui::GetIO().BackendRendererUserData : nullptr;
+    return ImGui::GetCurrentContext() ? (ImGui_ImplSDLRenderer_Data*) ImGui::GetIO().BackendRendererUserData : nullptr;
 }

 // Functions
@@ -62,9 +70,9 @@ bool ImGui_ImplSDLRenderer_Init(SDL_Renderer* renderer)

     // Setup backend capabilities flags
     ImGui_ImplSDLRenderer_Data* bd = IM_NEW(ImGui_ImplSDLRenderer_Data)();
-    io.BackendRendererUserData = (void*)bd;
+    io.BackendRendererUserData = (void*) bd;
     io.BackendRendererName = "imgui_impl_sdlrenderer";
-    io.BackendFlags |= ImGuiBackendFlags_RendererHasVtxOffset;  // We can honor the ImDrawCmd::VtxOffset field, allowing for large meshes.
+    io.BackendFlags |= ImGuiBackendFlags_RendererHasVtxOffset; // We can honor the ImDrawCmd::VtxOffset field, allowing for large meshes.

     bd->SDLRenderer = renderer;

@@ -86,12 +94,12 @@ void ImGui_ImplSDLRenderer_Shutdown()

 static void ImGui_ImplSDLRenderer_SetupRenderState()
 {
-	ImGui_ImplSDLRenderer_Data* bd = ImGui_ImplSDLRenderer_GetBackendData();
+    ImGui_ImplSDLRenderer_Data* bd = ImGui_ImplSDLRenderer_GetBackendData();

-	// Clear out any viewports and cliprect set by the user
+    // Clear out any viewports and cliprect set by the user
     // FIXME: Technically speaking there are lots of other things we could backup/setup/restore during our render process.
-	SDL_RenderSetViewport(bd->SDLRenderer, nullptr);
-	SDL_RenderSetClipRect(bd->SDLRenderer, nullptr);
+    SDL_RenderSetViewport(bd->SDLRenderer, nullptr);
+    SDL_RenderSetClipRect(bd->SDLRenderer, nullptr);
 }

 void ImGui_ImplSDLRenderer_NewFrame()
@@ -105,39 +113,39 @@ void ImGui_ImplSDLRenderer_NewFrame()

 void ImGui_ImplSDLRenderer_RenderDrawData(ImDrawData* draw_data)
 {
-	ImGui_ImplSDLRenderer_Data* bd = ImGui_ImplSDLRenderer_GetBackendData();
+    ImGui_ImplSDLRenderer_Data* bd = ImGui_ImplSDLRenderer_GetBackendData();

-	// If there's a scale factor set by the user, use that instead
+    // If there's a scale factor set by the user, use that instead
     // If the user has specified a scale factor to SDL_Renderer already via SDL_RenderSetScale(), SDL will scale whatever we pass
     // to SDL_RenderGeometryRaw() by that scale factor. In that case we don't want to be also scaling it ourselves here.
     float rsx = 1.0f;
-	float rsy = 1.0f;
-	SDL_RenderGetScale(bd->SDLRenderer, &rsx, &rsy);
+    float rsy = 1.0f;
+    SDL_RenderGetScale(bd->SDLRenderer, &rsx, &rsy);
     ImVec2 render_scale;
-	render_scale.x = (rsx == 1.0f) ? draw_data->FramebufferScale.x : 1.0f;
-	render_scale.y = (rsy == 1.0f) ? draw_data->FramebufferScale.y : 1.0f;
+    render_scale.x = (rsx == 1.0f) ? draw_data->FramebufferScale.x : 1.0f;
+    render_scale.y = (rsy == 1.0f) ? draw_data->FramebufferScale.y : 1.0f;

-	// Avoid rendering when minimized, scale coordinates for retina displays (screen coordinates != framebuffer coordinates)
-	int fb_width = (int)(draw_data->DisplaySize.x * render_scale.x);
-	int fb_height = (int)(draw_data->DisplaySize.y * render_scale.y);
-	if (fb_width == 0 || fb_height == 0)
-		return;
+    // Avoid rendering when minimized, scale coordinates for retina displays (screen coordinates != framebuffer coordinates)
+    int fb_width = (int) (draw_data->DisplaySize.x * render_scale.x);
+    int fb_height = (int) (draw_data->DisplaySize.y * render_scale.y);
+    if (fb_width == 0 || fb_height == 0)
+        return;

     // Backup SDL_Renderer state that will be modified to restore it afterwards
     struct BackupSDLRendererState
     {
-        SDL_Rect    Viewport;
-        bool        ClipEnabled;
-        SDL_Rect    ClipRect;
+        SDL_Rect Viewport;
+        bool ClipEnabled;
+        SDL_Rect ClipRect;
     };
     BackupSDLRendererState old = {};
     old.ClipEnabled = SDL_RenderIsClipEnabled(bd->SDLRenderer) == SDL_TRUE;
     SDL_RenderGetViewport(bd->SDLRenderer, &old.Viewport);
     SDL_RenderGetClipRect(bd->SDLRenderer, &old.ClipRect);

-	// Will project scissor/clipping rectangles into framebuffer space
-	ImVec2 clip_off = draw_data->DisplayPos;         // (0,0) unless using multi-viewports
-	ImVec2 clip_scale = render_scale;
+    // Will project scissor/clipping rectangles into framebuffer space
+    ImVec2 clip_off = draw_data->DisplayPos; // (0,0) unless using multi-viewports
+    ImVec2 clip_scale = render_scale;

     // Render command lists
     ImGui_ImplSDLRenderer_SetupRenderState();
@@ -164,32 +172,44 @@ void ImGui_ImplSDLRenderer_RenderDrawData(ImDrawData* draw_data)
                 // Project scissor/clipping rectangles into framebuffer space
                 ImVec2 clip_min((pcmd->ClipRect.x - clip_off.x) * clip_scale.x, (pcmd->ClipRect.y - clip_off.y) * clip_scale.y);
                 ImVec2 clip_max((pcmd->ClipRect.z - clip_off.x) * clip_scale.x, (pcmd->ClipRect.w - clip_off.y) * clip_scale.y);
-                if (clip_min.x < 0.0f) { clip_min.x = 0.0f; }
-                if (clip_min.y < 0.0f) { clip_min.y = 0.0f; }
-                if (clip_max.x > (float)fb_width) { clip_max.x = (float)fb_width; }
-                if (clip_max.y > (float)fb_height) { clip_max.y = (float)fb_height; }
+                if (clip_min.x < 0.0f)
+                {
+                    clip_min.x = 0.0f;
+                }
+                if (clip_min.y < 0.0f)
+                {
+                    clip_min.y = 0.0f;
+                }
+                if (clip_max.x > (float) fb_width)
+                {
+                    clip_max.x = (float) fb_width;
+                }
+                if (clip_max.y > (float) fb_height)
+                {
+                    clip_max.y = (float) fb_height;
+                }
                 if (clip_max.x <= clip_min.x || clip_max.y <= clip_min.y)
                     continue;

-                SDL_Rect r = { (int)(clip_min.x), (int)(clip_min.y), (int)(clip_max.x - clip_min.x), (int)(clip_max.y - clip_min.y) };
+                SDL_Rect r = {(int) (clip_min.x), (int) (clip_min.y), (int) (clip_max.x - clip_min.x), (int) (clip_max.y - clip_min.y)};
                 SDL_RenderSetClipRect(bd->SDLRenderer, &r);

-                const float* xy = (const float*)(const void*)((const char*)(vtx_buffer + pcmd->VtxOffset) + IM_OFFSETOF(ImDrawVert, pos));
-                const float* uv = (const float*)(const void*)((const char*)(vtx_buffer + pcmd->VtxOffset) + IM_OFFSETOF(ImDrawVert, uv));
-#if SDL_VERSION_ATLEAST(2,0,19)
-                const SDL_Color* color = (const SDL_Color*)(const void*)((const char*)(vtx_buffer + pcmd->VtxOffset) + IM_OFFSETOF(ImDrawVert, col)); // SDL 2.0.19+
-#else
-                const int* color = (const int*)(const void*)((const char*)(vtx_buffer + pcmd->VtxOffset) + IM_OFFSETOF(ImDrawVert, col)); // SDL 2.0.17 and 2.0.18
-#endif
+                const float* xy = (const float*) (const void*) ((const char*) (vtx_buffer + pcmd->VtxOffset) + IM_OFFSETOF(ImDrawVert, pos));
+                const float* uv = (const float*) (const void*) ((const char*) (vtx_buffer + pcmd->VtxOffset) + IM_OFFSETOF(ImDrawVert, uv));
+                #if SDL_VERSION_ATLEAST(2, 0, 19)
+                const SDL_Color* color = (const SDL_Color*) (const void*) ((const char*) (vtx_buffer + pcmd->VtxOffset) + IM_OFFSETOF(ImDrawVert, col)); // SDL 2.0.19+
+                #else
+                const int* color = (const int*) (const void*) ((const char*) (vtx_buffer + pcmd->VtxOffset) + IM_OFFSETOF(ImDrawVert, col)); // SDL 2.0.17 and 2.0.18
+                #endif

                 // Bind texture, Draw
-				SDL_Texture* tex = (SDL_Texture*)pcmd->GetTexID();
+                SDL_Texture* tex = (SDL_Texture*) pcmd->GetTexID();
                 SDL_RenderGeometryRaw(bd->SDLRenderer, tex,
-                    xy, (int)sizeof(ImDrawVert),
-                    color, (int)sizeof(ImDrawVert),
-                    uv, (int)sizeof(ImDrawVert),
-                    cmd_list->VtxBuffer.Size - pcmd->VtxOffset,
-                    idx_buffer + pcmd->IdxOffset, pcmd->ElemCount, sizeof(ImDrawIdx));
+                                      xy, (int) sizeof(ImDrawVert),
+                                      color, (int) sizeof(ImDrawVert),
+                                      uv, (int) sizeof(ImDrawVert),
+                                      cmd_list->VtxBuffer.Size - pcmd->VtxOffset,
+                                      idx_buffer + pcmd->IdxOffset, pcmd->ElemCount, sizeof(ImDrawIdx));
             }
         }
     }
@@ -208,7 +228,7 @@ bool ImGui_ImplSDLRenderer_CreateFontsTexture()
     // Build texture atlas
     unsigned char* pixels;
     int width, height;
-    io.Fonts->GetTexDataAsRGBA32(&pixels, &width, &height);   // Load as RGBA 32-bit (75% of the memory is wasted, but default font is so small) because it is more likely to be compatible with user's existing shaders. If your ImTextureId represent a higher-level concept than just a GL texture id, consider calling GetTexDataAsAlpha8() instead to save on GPU memory.
+    io.Fonts->GetTexDataAsRGBA32(&pixels, &width, &height); // Load as RGBA 32-bit (75% of the memory is wasted, but default font is so small) because it is more likely to be compatible with user's existing shaders. If your ImTextureId represent a higher-level concept than just a GL texture id, consider calling GetTexDataAsAlpha8() instead to save on GPU memory.

     // Upload texture to graphics system
     // (Bilinear sampling is required by default. Set 'io.Fonts->Flags |= ImFontAtlasFlags_NoBakedLines' or 'style.AntiAliasedLinesUseTex = false' to allow point/nearest sampling)
@@ -223,7 +243,7 @@ bool ImGui_ImplSDLRenderer_CreateFontsTexture()
     SDL_SetTextureScaleMode(bd->FontTexture, SDL_ScaleModeLinear);

     // Store our identifier
-    io.Fonts->SetTexID((ImTextureID)(intptr_t)bd->FontTexture);
+    io.Fonts->SetTexID((ImTextureID) (intptr_t) bd->FontTexture);

     return true;
 }
@@ -249,3 +269,1429 @@ void ImGui_ImplSDLRenderer_DestroyDeviceObjects()
 {
     ImGui_ImplSDLRenderer_DestroyFontsTexture();
 }
+#else
+
+struct ImGui_ImplSDLRenderer_TextureCacheEntry
+{
+    std::vector<Uint32> Pixels;
+    int Width = 0;
+    int Height = 0;
+    int Pitch = 0;
+    Uint32 Format = 0;
+    Uint8 RShift = 0;
+    Uint8 GShift = 0;
+    Uint8 BShift = 0;
+    Uint8 AShift = 0;
+    Uint32 RMask = 0;
+    Uint32 GMask = 0;
+    Uint32 BMask = 0;
+    Uint32 AMask = 0;
+    float RScale = 1.0f;
+    float GScale = 1.0f;
+    float BScale = 1.0f;
+    float AScale = 1.0f;
+    bool Valid = false;
+    bool PermanentFailure = false;
+};
+
+struct ImGui_ImplSDLRenderer_TextureSample
+{
+    const Uint32* Pixels = nullptr;
+    int Width = 0;
+    int Height = 0;
+    int Pitch = 0;
+    Uint8 RShift = 0;
+    Uint8 GShift = 0;
+    Uint8 BShift = 0;
+    Uint8 AShift = 0;
+    Uint32 RMask = 0;
+    Uint32 GMask = 0;
+    Uint32 BMask = 0;
+    Uint32 AMask = 0;
+    float RScale = 1.0f;
+    float GScale = 1.0f;
+    float BScale = 1.0f;
+    float AScale = 1.0f;
+    bool Valid = false;
+};
+
+struct ImGui_ImplSDLRenderer_Data
+{
+    SDL_Renderer* SDLRenderer;
+    SDL_Texture* FontTexture;
+    SDL_Texture* FrameTexture;
+    std::vector<ImU32> FontPixels;
+    int FontWidth;
+    int FontHeight;
+    std::vector<Uint32> Framebuffer;
+    int FrameWidth;
+    int FrameHeight;
+    int MinDirtyX, MinDirtyY, MaxDirtyX, MaxDirtyY;
+    bool HasDirtyRegion;
+    bool EnableProfiling;
+    int ProfileLogFrequency;
+    int ProfileCounter;
+    Uint64 PerfFrequency;
+    int LastDirtyPixels;
+    bool LastFrameHadWork;
+    bool CachedFrameValid;
+    Uint64 LastFrameHash;
+    std::unordered_map<SDL_Texture*, ImGui_ImplSDLRenderer_TextureCacheEntry> TextureCache;
+
+    ImGui_ImplSDLRenderer_Data()
+    : SDLRenderer(nullptr), FontTexture(nullptr), FrameTexture(nullptr), FontWidth(0), FontHeight(0), FrameWidth(0), FrameHeight(0), MinDirtyX(0), MinDirtyY(0), MaxDirtyX(0), MaxDirtyY(0), HasDirtyRegion(false), EnableProfiling(false), ProfileLogFrequency(120), ProfileCounter(0), PerfFrequency(0), LastDirtyPixels(0), LastFrameHadWork(false), CachedFrameValid(false), LastFrameHash(0)
+    {
+    }
+};
+
+static ImGui_ImplSDLRenderer_Data* ImGui_ImplSDLRenderer_GetBackendData()
+{
+    return ImGui::GetCurrentContext() ? (ImGui_ImplSDLRenderer_Data*) ImGui::GetIO().BackendRendererUserData : nullptr;
+}
+
+static void ImGui_ImplSDLRenderer_SetupRenderState()
+{
+    ImGui_ImplSDLRenderer_Data* bd = ImGui_ImplSDLRenderer_GetBackendData();
+    SDL_RenderSetViewport(bd->SDLRenderer, nullptr);
+    SDL_RenderSetClipRect(bd->SDLRenderer, nullptr);
+}
+
+static Uint64 ImGui_ImplSDLRenderer_HashDrawData(const ImDrawData* draw_data)
+{
+    const Uint64 fnv_offset = 1469598103934665603ULL;
+    const Uint64 fnv_prime = 1099511628211ULL;
+    Uint64 hash = fnv_offset;
+
+    auto hash_bytes = [&](const void* data, size_t size)
+    {
+        const unsigned char* bytes = static_cast<const unsigned char*>(data);
+        for (size_t i = 0; i < size; ++i)
+        {
+            hash ^= bytes[i];
+            hash *= fnv_prime;
+        }
+    };
+
+    hash_bytes(&draw_data->DisplayPos, sizeof(draw_data->DisplayPos));
+    hash_bytes(&draw_data->DisplaySize, sizeof(draw_data->DisplaySize));
+    hash_bytes(&draw_data->FramebufferScale, sizeof(draw_data->FramebufferScale));
+    hash_bytes(&draw_data->CmdListsCount, sizeof(draw_data->CmdListsCount));
+
+    for (int n = 0; n < draw_data->CmdListsCount; ++n)
+    {
+        const ImDrawList* cmd_list = draw_data->CmdLists[n];
+        hash_bytes(&cmd_list->VtxBuffer.Size, sizeof(cmd_list->VtxBuffer.Size));
+        if (cmd_list->VtxBuffer.Size > 0)
+            hash_bytes(cmd_list->VtxBuffer.Data, (size_t) cmd_list->VtxBuffer.Size * sizeof(ImDrawVert));
+
+        hash_bytes(&cmd_list->IdxBuffer.Size, sizeof(cmd_list->IdxBuffer.Size));
+        if (cmd_list->IdxBuffer.Size > 0)
+            hash_bytes(cmd_list->IdxBuffer.Data, (size_t) cmd_list->IdxBuffer.Size * sizeof(ImDrawIdx));
+
+        hash_bytes(&cmd_list->CmdBuffer.Size, sizeof(cmd_list->CmdBuffer.Size));
+        for (int cmd_i = 0; cmd_i < cmd_list->CmdBuffer.Size; ++cmd_i)
+        {
+            const ImDrawCmd& cmd = cmd_list->CmdBuffer[cmd_i];
+            hash_bytes(&cmd.ClipRect, sizeof(cmd.ClipRect));
+            hash_bytes(&cmd.ElemCount, sizeof(cmd.ElemCount));
+            hash_bytes(&cmd.IdxOffset, sizeof(cmd.IdxOffset));
+            hash_bytes(&cmd.VtxOffset, sizeof(cmd.VtxOffset));
+
+            const uintptr_t tex_id = (uintptr_t) cmd.GetTexID();
+            hash_bytes(&tex_id, sizeof(tex_id));
+
+            hash_bytes(&cmd.UserCallback, sizeof(cmd.UserCallback));
+            hash_bytes(&cmd.UserCallbackData, sizeof(cmd.UserCallbackData));
+        }
+    }
+
+    return hash;
+}
+
+static int ImGui_ImplSDLRenderer_CalcShift(Uint32 mask)
+{
+    if (mask == 0)
+        return 0;
+    int shift = 0;
+    while ((mask & 1u) == 0u)
+    {
+        mask >>= 1;
+        shift++;
+    }
+    return shift;
+}
+
+static float ImGui_ImplSDLRenderer_CalcScale(Uint32 mask, int shift)
+{
+    if (mask == 0)
+        return 1.0f;
+    Uint32 component_max = mask >> shift;
+    if (component_max == 0)
+        return 1.0f;
+    return 1.0f / static_cast<float>(component_max);
+}
+
+static bool ImGui_ImplSDLRenderer_LoadTextureToCache(SDL_Texture* texture,
+                                                     int width,
+                                                     int height,
+                                                     Uint32 format,
+                                                     ImGui_ImplSDLRenderer_TextureCacheEntry& entry)
+{
+    if (texture == nullptr || width <= 0 || height <= 0)
+        return false;
+
+    void* pixels = nullptr;
+    int pitch = 0;
+    if (SDL_LockTexture(texture, nullptr, &pixels, &pitch) != 0)
+        return false;
+
+    entry.Pixels.resize(static_cast<size_t>(width) * static_cast<size_t>(height));
+    const Uint8* src_bytes = static_cast<const Uint8*>(pixels);
+    for (int y = 0; y < height; ++y)
+    {
+        const Uint32* row = reinterpret_cast<const Uint32*>(src_bytes + static_cast<size_t>(y) * pitch);
+        std::copy(row, row + width, entry.Pixels.begin() + static_cast<size_t>(y) * width);
+    }
+    SDL_UnlockTexture(texture);
+
+    entry.Width = width;
+    entry.Height = height;
+    entry.Pitch = width;
+    entry.Format = format;
+
+    int bpp = 0;
+    Uint32 rmask = 0, gmask = 0, bmask = 0, amask = 0;
+    if (!SDL_PixelFormatEnumToMasks(format, &bpp, &rmask, &gmask, &bmask, &amask) || bpp != 32)
+    {
+        rmask = 0x00FF0000u;
+        gmask = 0x0000FF00u;
+        bmask = 0x000000FFu;
+        amask = 0xFF000000u;
+    }
+
+    entry.RMask = rmask;
+    entry.GMask = gmask;
+    entry.BMask = bmask;
+    entry.AMask = amask;
+    entry.RShift = (Uint8) ImGui_ImplSDLRenderer_CalcShift(rmask);
+    entry.GShift = (Uint8) ImGui_ImplSDLRenderer_CalcShift(gmask);
+    entry.BShift = (Uint8) ImGui_ImplSDLRenderer_CalcShift(bmask);
+    entry.AShift = (Uint8) ImGui_ImplSDLRenderer_CalcShift(amask);
+    entry.RScale = ImGui_ImplSDLRenderer_CalcScale(rmask, entry.RShift);
+    entry.GScale = ImGui_ImplSDLRenderer_CalcScale(gmask, entry.GShift);
+    entry.BScale = ImGui_ImplSDLRenderer_CalcScale(bmask, entry.BShift);
+    entry.AScale = ImGui_ImplSDLRenderer_CalcScale(amask, entry.AShift);
+    entry.Valid = true;
+    entry.PermanentFailure = false;
+    return true;
+}
+
+static ImGui_ImplSDLRenderer_TextureSample ImGui_ImplSDLRenderer_GetTextureSample(ImGui_ImplSDLRenderer_Data* bd, SDL_Texture* texture)
+{
+    ImGui_ImplSDLRenderer_TextureSample sample;
+    if (texture == nullptr)
+        return sample;
+
+    if (texture == bd->FontTexture && !bd->FontPixels.empty() && bd->FontWidth > 0 && bd->FontHeight > 0)
+    {
+        sample.Pixels = bd->FontPixels.data();
+        sample.Width = bd->FontWidth;
+        sample.Height = bd->FontHeight;
+        sample.Pitch = bd->FontWidth;
+        sample.RMask = ((Uint32) 0xFFu) << IM_COL32_R_SHIFT;
+        sample.GMask = ((Uint32) 0xFFu) << IM_COL32_G_SHIFT;
+        sample.BMask = ((Uint32) 0xFFu) << IM_COL32_B_SHIFT;
+        sample.AMask = ((Uint32) 0xFFu) << IM_COL32_A_SHIFT;
+        sample.RShift = IM_COL32_R_SHIFT;
+        sample.GShift = IM_COL32_G_SHIFT;
+        sample.BShift = IM_COL32_B_SHIFT;
+        sample.AShift = IM_COL32_A_SHIFT;
+        sample.RScale = 1.0f / 255.0f;
+        sample.GScale = 1.0f / 255.0f;
+        sample.BScale = 1.0f / 255.0f;
+        sample.AScale = 1.0f / 255.0f;
+        sample.Valid = true;
+        return sample;
+    }
+
+    Uint32 format = 0;
+    int access = 0;
+    int width = 0;
+    int height = 0;
+    if (SDL_QueryTexture(texture, &format, &access, &width, &height) != 0 || width <= 0 || height <= 0)
+        return sample;
+
+    auto it = bd->TextureCache.find(texture);
+    if (it == bd->TextureCache.end())
+    {
+        it = bd->TextureCache.emplace(texture, ImGui_ImplSDLRenderer_TextureCacheEntry{}).first;
+    }
+
+    ImGui_ImplSDLRenderer_TextureCacheEntry& entry = it->second;
+    const bool signature_matches = entry.Valid && entry.Width == width && entry.Height == height && entry.Format == format;
+    if (entry.PermanentFailure && signature_matches)
+        return sample;
+
+    if (!signature_matches)
+    {
+        entry.Valid = false;
+        entry.PermanentFailure = false;
+    }
+
+    if (!entry.Valid)
+    {
+        if (!ImGui_ImplSDLRenderer_LoadTextureToCache(texture, width, height, format, entry))
+        {
+            if (!entry.PermanentFailure)
+            {
+                entry.Pixels.clear();
+                entry.Width = width;
+                entry.Height = height;
+                entry.Pitch = 0;
+                entry.Format = format;
+                entry.Valid = false;
+                entry.PermanentFailure = true;
+                SDL_Log("ImGui legacy renderer: unable to sample texture %p (format=0x%x, access=%d): %s",
+                        (void*) texture, format, access, SDL_GetError());
+            }
+            return sample;
+        }
+    }
+
+    if (!entry.Valid || entry.Pixels.empty())
+        return sample;
+
+    sample.Pixels = entry.Pixels.data();
+    sample.Width = entry.Width;
+    sample.Height = entry.Height;
+    sample.Pitch = entry.Pitch;
+    sample.RMask = entry.RMask;
+    sample.GMask = entry.GMask;
+    sample.BMask = entry.BMask;
+    sample.AMask = entry.AMask;
+    sample.RShift = entry.RShift;
+    sample.GShift = entry.GShift;
+    sample.BShift = entry.BShift;
+    sample.AShift = entry.AShift;
+    sample.RScale = entry.RScale;
+    sample.GScale = entry.GScale;
+    sample.BScale = entry.BScale;
+    sample.AScale = entry.AScale;
+    sample.Valid = true;
+    return sample;
+}
+
+static bool ImGui_ImplSDLRenderer_EnsureFramebuffer(ImGui_ImplSDLRenderer_Data* bd, int width, int height)
+{
+    if (width <= 0 || height <= 0)
+        return false;
+
+    if (bd->FrameWidth != width || bd->FrameHeight != height || bd->FrameTexture == nullptr)
+    {
+        if (bd->FrameTexture)
+        {
+            SDL_DestroyTexture(bd->FrameTexture);
+            bd->FrameTexture = nullptr;
+        }
+
+        bd->Framebuffer.resize((size_t) width * (size_t) height);
+        bd->FrameWidth = width;
+        bd->FrameHeight = height;
+
+        bd->FrameTexture = SDL_CreateTexture(bd->SDLRenderer, SDL_PIXELFORMAT_ABGR8888, SDL_TEXTUREACCESS_STREAMING, width, height);
+        if (bd->FrameTexture == nullptr)
+        {
+            SDL_Log("Failed to create ImGui legacy framebuffer: %s", SDL_GetError());
+            bd->Framebuffer.clear();
+            bd->FrameWidth = 0;
+            bd->FrameHeight = 0;
+            return false;
+        }
+
+        SDL_SetTextureBlendMode(bd->FrameTexture, SDL_BLENDMODE_BLEND);
+        // Clear entire buffer on resize
+        std::fill(bd->Framebuffer.begin(), bd->Framebuffer.end(), 0u);
+        bd->CachedFrameValid = false;
+
+        if (!bd->Framebuffer.empty())
+        {
+            SDL_UpdateTexture(bd->FrameTexture, nullptr, bd->Framebuffer.data(), width * (int) sizeof(Uint32));
+        }
+    }
+    else if (bd->HasDirtyRegion)
+    {
+        // Only clear the dirty region from previous frame
+        int dirty_w = bd->MaxDirtyX - bd->MinDirtyX + 1;
+        int dirty_h = bd->MaxDirtyY - bd->MinDirtyY + 1;
+
+        if (dirty_w > 0 && dirty_h > 0)
+        {
+            for (int y = bd->MinDirtyY; y <= bd->MaxDirtyY && y < bd->FrameHeight; ++y)
+            {
+                size_t start_idx = (size_t) y * bd->FrameWidth + bd->MinDirtyX;
+                size_t count = std::min(dirty_w, bd->FrameWidth - bd->MinDirtyX);
+                std::fill(bd->Framebuffer.begin() + start_idx, bd->Framebuffer.begin() + start_idx + count, 0u);
+            }
+        }
+    }
+
+    // Reset dirty region tracking
+    bd->HasDirtyRegion = false;
+    bd->MinDirtyX = bd->FrameWidth;
+    bd->MinDirtyY = bd->FrameHeight;
+    bd->MaxDirtyX = -1;
+    bd->MaxDirtyY = -1;
+    bd->LastDirtyPixels = 0;
+    bd->LastFrameHadWork = false;
+
+    return true;
+}
+
+static ImVec4 ImGui_ImplSDLRenderer_UnpackColor(ImU32 col)
+{
+    const float inv255 = 1.0f / 255.0f;
+    return ImVec4(
+        ((col >> IM_COL32_R_SHIFT) & 0xFF) * inv255,
+                  ((col >> IM_COL32_G_SHIFT) & 0xFF) * inv255,
+                  ((col >> IM_COL32_B_SHIFT) & 0xFF) * inv255,
+                  ((col >> IM_COL32_A_SHIFT) & 0xFF) * inv255);
+}
+
+static inline ImVec4 ImGui_ImplSDLRenderer_CombineColor(const ImVec4& c0, const ImVec4& c1, const ImVec4& c2, float w0, float w1, float w2)
+{
+    return ImVec4(
+        c0.x * w0 + c1.x * w1 + c2.x * w2,
+        c0.y * w0 + c1.y * w1 + c2.y * w2,
+        c0.z * w0 + c1.z * w1 + c2.z * w2,
+        c0.w * w0 + c1.w * w1 + c2.w * w2);
+}
+
+static inline ImVec4 ImGui_ImplSDLRenderer_Lerp(const ImVec4& a, const ImVec4& b, float t)
+{
+    return ImVec4(
+        a.x + (b.x - a.x) * t,
+                  a.y + (b.y - a.y) * t,
+                  a.z + (b.z - a.z) * t,
+                  a.w + (b.w - a.w) * t);
+}
+
+static inline ImVec2 ImGui_ImplSDLRenderer_CombineUV(const ImVec2& uv0, const ImVec2& uv1, const ImVec2& uv2, float w0, float w1, float w2)
+{
+    return ImVec2(
+        uv0.x * w0 + uv1.x * w1 + uv2.x * w2,
+        uv0.y * w0 + uv1.y * w1 + uv2.y * w2);
+}
+
+static inline ImVec2 ImGui_ImplSDLRenderer_Lerp(const ImVec2& a, const ImVec2& b, float t)
+{
+    return ImVec2(
+        a.x + (b.x - a.x) * t,
+                  a.y + (b.y - a.y) * t);
+}
+
+static inline bool ImGui_ImplSDLRenderer_IsTopLeft(const ImVec2& a, const ImVec2& b)
+{
+    const float dy = b.y - a.y;
+    if (dy > 0.0f)
+        return true;
+    if (dy < 0.0f)
+        return false;
+    return (b.x - a.x) < 0.0f;
+}
+
+static inline void ImGui_ImplSDLRenderer_UnpackTexel(const ImGui_ImplSDLRenderer_TextureSample& texture, Uint32 texel,
+                                                     float& out_r, float& out_g, float& out_b, float& out_a)
+{
+    out_r = ((texel & texture.RMask) >> texture.RShift) * texture.RScale;
+    out_g = ((texel & texture.GMask) >> texture.GShift) * texture.GScale;
+    out_b = ((texel & texture.BMask) >> texture.BShift) * texture.BScale;
+    out_a = ((texel & texture.AMask) >> texture.AShift) * texture.AScale;
+}
+
+static inline void ImGui_ImplSDLRenderer_SampleTextureBilinear(const ImGui_ImplSDLRenderer_TextureSample& texture,
+                                                               float u, float v,
+                                                               float& tex_r, float& tex_g, float& tex_b, float& tex_a)
+{
+    if (texture.Width <= 0 || texture.Height <= 0 || texture.Pitch <= 0 || texture.Pixels == nullptr)
+    {
+        tex_r = tex_g = tex_b = tex_a = 1.0f;
+        return;
+    }
+
+    u = std::clamp(u, 0.0f, 1.0f);
+    v = std::clamp(v, 0.0f, 1.0f);
+
+    float tex_x = u * static_cast<float>(texture.Width) - 0.5f;
+    float tex_y = v * static_cast<float>(texture.Height) - 0.5f;
+
+    int x0 = static_cast<int>(std::floor(tex_x));
+    int y0 = static_cast<int>(std::floor(tex_y));
+    int x1 = x0 + 1;
+    int y1 = y0 + 1;
+
+    float fx = tex_x - static_cast<float>(x0);
+    float fy = tex_y - static_cast<float>(y0);
+
+    x0 = std::clamp(x0, 0, texture.Width - 1);
+    y0 = std::clamp(y0, 0, texture.Height - 1);
+    x1 = std::clamp(x1, 0, texture.Width - 1);
+    y1 = std::clamp(y1, 0, texture.Height - 1);
+
+    if (x0 == x1)
+        fx = 0.0f;
+    if (y0 == y1)
+        fy = 0.0f;
+
+    const Uint32 texel00 = texture.Pixels[static_cast<size_t>(y0) * texture.Pitch + static_cast<size_t>(x0)];
+    const Uint32 texel10 = texture.Pixels[static_cast<size_t>(y0) * texture.Pitch + static_cast<size_t>(x1)];
+    const Uint32 texel01 = texture.Pixels[static_cast<size_t>(y1) * texture.Pitch + static_cast<size_t>(x0)];
+    const Uint32 texel11 = texture.Pixels[static_cast<size_t>(y1) * texture.Pitch + static_cast<size_t>(x1)];
+
+    float r00, g00, b00, a00;
+    float r10, g10, b10, a10;
+    float r01, g01, b01, a01;
+    float r11, g11, b11, a11;
+
+    ImGui_ImplSDLRenderer_UnpackTexel(texture, texel00, r00, g00, b00, a00);
+    ImGui_ImplSDLRenderer_UnpackTexel(texture, texel10, r10, g10, b10, a10);
+    ImGui_ImplSDLRenderer_UnpackTexel(texture, texel01, r01, g01, b01, a01);
+    ImGui_ImplSDLRenderer_UnpackTexel(texture, texel11, r11, g11, b11, a11);
+
+    const float w00 = (1.0f - fx) * (1.0f - fy);
+    const float w10 = fx * (1.0f - fy);
+    const float w01 = (1.0f - fx) * fy;
+    const float w11 = fx * fy;
+
+    tex_r = r00 * w00 + r10 * w10 + r01 * w01 + r11 * w11;
+    tex_g = g00 * w00 + g10 * w10 + g01 * w01 + g11 * w11;
+    tex_b = b00 * w00 + b10 * w10 + b01 * w01 + b11 * w11;
+    tex_a = a00 * w00 + a10 * w10 + a01 * w01 + a11 * w11;
+}
+
+static bool ImGui_ImplSDLRenderer_TryRasterizeRect(
+    ImGui_ImplSDLRenderer_Data* bd,
+    const ImDrawVert* vtx_buffer,
+    const ImDrawIdx* idx_buffer,
+    unsigned int idx_offset,
+    unsigned int vtx_offset,
+    const ImVec2& clip_off,
+    const ImVec2& clip_scale,
+    const SDL_Rect& clip_rect,
+    const ImGui_ImplSDLRenderer_TextureSample& texture)
+{
+    unsigned int indices[6];
+    for (int i = 0; i < 6; ++i)
+        indices[i] = vtx_offset + (unsigned int) idx_buffer[idx_offset + i];
+
+    unsigned int unique_indices[4];
+    int unique_count = 0;
+    for (int i = 0; i < 6; ++i)
+    {
+        unsigned int idx = indices[i];
+        bool found = false;
+        for (int u = 0; u < unique_count; ++u)
+        {
+            if (unique_indices[u] == idx)
+            {
+                found = true;
+                break;
+            }
+        }
+        if (!found)
+        {
+            if (unique_count == 4)
+                return false;
+            unique_indices[unique_count++] = idx;
+        }
+    }
+    if (unique_count != 4)
+        return false;
+
+    struct CornerData
+    {
+        ImVec2 Pos;
+        ImVec2 UV;
+        ImVec4 Col;
+    };
+
+    CornerData corners_raw[4];
+    for (int i = 0; i < 4; ++i)
+    {
+        const ImDrawVert& v = vtx_buffer[unique_indices[i]];
+        corners_raw[i].Pos = ImVec2((v.pos.x - clip_off.x) * clip_scale.x,
+                                    (v.pos.y - clip_off.y) * clip_scale.y);
+        corners_raw[i].UV = v.uv;
+        corners_raw[i].Col = ImGui_ImplSDLRenderer_UnpackColor(v.col);
+    }
+
+    float min_x = corners_raw[0].Pos.x;
+    float max_x = corners_raw[0].Pos.x;
+    float min_y = corners_raw[0].Pos.y;
+    float max_y = corners_raw[0].Pos.y;
+    for (int i = 1; i < 4; ++i)
+    {
+        min_x = std::min(min_x, corners_raw[i].Pos.x);
+        max_x = std::max(max_x, corners_raw[i].Pos.x);
+        min_y = std::min(min_y, corners_raw[i].Pos.y);
+        max_y = std::max(max_y, corners_raw[i].Pos.y);
+    }
+
+    const float width = max_x - min_x;
+    const float height = max_y - min_y;
+    if (width <= 0.0f || height <= 0.0f)
+        return false;
+
+    CornerData tl{}, tr{}, bl{}, br{};
+    bool has_tl = false, has_tr = false, has_bl = false, has_br = false;
+    const float eps = 0.05f;
+
+    for (int i = 0; i < 4; ++i)
+    {
+        const CornerData& c = corners_raw[i];
+        const bool left = fabsf(c.Pos.x - min_x) <= eps;
+        const bool right = fabsf(c.Pos.x - max_x) <= eps;
+        const bool top = fabsf(c.Pos.y - min_y) <= eps;
+        const bool bottom = fabsf(c.Pos.y - max_y) <= eps;
+
+        if (top && left && !has_tl)
+        {
+            tl = c;
+            has_tl = true;
+        }
+        else if (top && right && !has_tr)
+        {
+            tr = c;
+            has_tr = true;
+        }
+        else if (bottom && left && !has_bl)
+        {
+            bl = c;
+            has_bl = true;
+        }
+        else if (bottom && right && !has_br)
+        {
+            br = c;
+            has_br = true;
+        }
+        else
+        {
+            return false;
+        }
+    }
+
+    if (!has_tl || !has_tr || !has_bl || !has_br)
+        return false;
+
+    int x0 = std::max((int) std::floor(min_x), clip_rect.x);
+    int y0 = std::max((int) std::floor(min_y), clip_rect.y);
+    int x1 = std::min((int) std::ceil(max_x) - 1, clip_rect.x + clip_rect.w - 1);
+    int y1 = std::min((int) std::ceil(max_y) - 1, clip_rect.y + clip_rect.h - 1);
+    if (x0 > x1 || y0 > y1)
+        return false;
+
+    const bool has_texture = texture.Valid && texture.Pixels != nullptr && texture.Width > 0 && texture.Height > 0 && texture.Pitch > 0;
+
+    float inv_width = (width != 0.0f) ? (1.0f / width) : 0.0f;
+    float inv_height = (height != 0.0f) ? (1.0f / height) : 0.0f;
+
+    bool use_bilinear = has_texture;
+    if (has_texture && inv_width != 0.0f && inv_height != 0.0f)
+    {
+        ImVec2 uv_dx = ImVec2(tr.UV.x - tl.UV.x, tr.UV.y - tl.UV.y);
+        ImVec2 uv_dy = ImVec2(bl.UV.x - tl.UV.x, bl.UV.y - tl.UV.y);
+
+        float u_dx_pixels = fabsf(uv_dx.x * texture.Width * inv_width);
+        float v_dx_pixels = fabsf(uv_dx.y * texture.Height * inv_width);
+        float u_dy_pixels = fabsf(uv_dy.x * texture.Width * inv_height);
+        float v_dy_pixels = fabsf(uv_dy.y * texture.Height * inv_height);
+
+        const float eps_tex = 1e-3f;
+        if (u_dy_pixels < eps_tex && v_dx_pixels < eps_tex &&
+            fabsf(u_dx_pixels - 1.0f) < 2e-2f && fabsf(v_dy_pixels - 1.0f) < 2e-2f)
+        {
+            use_bilinear = false;
+        }
+    }
+
+    Uint32* framebuffer = bd->Framebuffer.data();
+    const int frame_width = bd->FrameWidth;
+
+    for (int y = y0; y <= y1; ++y)
+    {
+        float fy = ((y + 0.5f) - min_y) * inv_height;
+        fy = std::clamp(fy, 0.0f, 1.0f);
+
+        ImVec4 color_left = ImGui_ImplSDLRenderer_Lerp(tl.Col, bl.Col, fy);
+        ImVec4 color_right = ImGui_ImplSDLRenderer_Lerp(tr.Col, br.Col, fy);
+        ImVec4 color = color_left;
+        ImVec4 color_step = ImVec4(0, 0, 0, 0);
+
+        ImVec2 uv_left = ImGui_ImplSDLRenderer_Lerp(tl.UV, bl.UV, fy);
+        ImVec2 uv_right = ImGui_ImplSDLRenderer_Lerp(tr.UV, br.UV, fy);
+        ImVec2 uv = uv_left;
+        ImVec2 uv_step = ImVec2(0, 0);
+
+        float fx = ((x0 + 0.5f) - min_x) * inv_width;
+        fx = std::clamp(fx, 0.0f, 1.0f);
+
+        if (inv_width != 0.0f)
+        {
+            ImVec4 row_delta = ImVec4(color_right.x - color_left.x,
+                                      color_right.y - color_left.y,
+                                      color_right.z - color_left.z,
+                                      color_right.w - color_left.w);
+            color_step.x = row_delta.x * inv_width;
+            color_step.y = row_delta.y * inv_width;
+            color_step.z = row_delta.z * inv_width;
+            color_step.w = row_delta.w * inv_width;
+
+            ImVec2 uv_delta = ImVec2(uv_right.x - uv_left.x, uv_right.y - uv_left.y);
+            uv_step.x = uv_delta.x * inv_width;
+            uv_step.y = uv_delta.y * inv_width;
+
+            color.x = color_left.x + row_delta.x * fx;
+            color.y = color_left.y + row_delta.y * fx;
+            color.z = color_left.z + row_delta.z * fx;
+            color.w = color_left.w + row_delta.w * fx;
+
+            uv.x = uv_left.x + uv_delta.x * fx;
+            uv.y = uv_left.y + uv_delta.y * fx;
+        }
+        else
+        {
+            color = color_left;
+            uv = uv_left;
+        }
+
+        Uint32* pixel_ptr = framebuffer + (size_t) y * frame_width + x0;
+        for (int x = x0; x <= x1; ++x, ++pixel_ptr)
+        {
+            float tex_r = 1.0f, tex_g = 1.0f, tex_b = 1.0f, tex_a = 1.0f;
+            if (has_texture)
+            {
+                if (use_bilinear)
+                {
+                    ImGui_ImplSDLRenderer_SampleTextureBilinear(texture, uv.x, uv.y, tex_r, tex_g, tex_b, tex_a);
+                }
+                else
+                {
+                    float u = uv.x;
+                    float v = uv.y;
+                    int tx = (int) (u * texture.Width + 0.5f);
+                    int ty = (int) (v * texture.Height + 0.5f);
+                    tx = std::clamp(tx, 0, texture.Width - 1);
+                    ty = std::clamp(ty, 0, texture.Height - 1);
+                    const Uint32 texel = texture.Pixels[static_cast<size_t>(ty) * texture.Pitch + static_cast<size_t>(tx)];
+                    ImGui_ImplSDLRenderer_UnpackTexel(texture, texel, tex_r, tex_g, tex_b, tex_a);
+                }
+            }
+
+            float src_a = color.w * tex_a;
+            if (src_a > 0.0f)
+            {
+                float src_r = color.x * tex_r;
+                float src_g = color.y * tex_g;
+                float src_b = color.z * tex_b;
+
+                if (!bd->HasDirtyRegion)
+                {
+                    bd->MinDirtyX = bd->MaxDirtyX = x;
+                    bd->MinDirtyY = bd->MaxDirtyY = y;
+                    bd->HasDirtyRegion = true;
+                }
+                else
+                {
+                    if (x < bd->MinDirtyX)
+                        bd->MinDirtyX = x;
+                    if (x > bd->MaxDirtyX)
+                        bd->MaxDirtyX = x;
+                    if (y < bd->MinDirtyY)
+                        bd->MinDirtyY = y;
+                    if (y > bd->MaxDirtyY)
+                        bd->MaxDirtyY = y;
+                }
+
+                if (src_a >= 1.0f)
+                {
+                    int r = (int) (src_r * 255.0f + 0.5f);
+                    int g = (int) (src_g * 255.0f + 0.5f);
+                    int b = (int) (src_b * 255.0f + 0.5f);
+                    r = (r > 255) ? 255 : (r < 0 ? 0 : r);
+                    g = (g > 255) ? 255 : (g < 0 ? 0 : g);
+                    b = (b > 255) ? 255 : (b < 0 ? 0 : b);
+
+                    *pixel_ptr = (Uint32) r | ((Uint32) g << 8) | ((Uint32) b << 16) | 0xFF000000;
+                }
+                else
+                {
+                    Uint32 dst = *pixel_ptr;
+                    int dst_r = (int) (dst & 0xFF);
+                    int dst_g = (int) ((dst >> 8) & 0xFF);
+                    int dst_b = (int) ((dst >> 16) & 0xFF);
+                    int dst_a = (int) ((dst >> 24) & 0xFF);
+
+                    int src_a_i = (int) (src_a * 255.0f + 0.5f);
+                    int src_r_i = (int) (src_r * 255.0f + 0.5f);
+                    int src_g_i = (int) (src_g * 255.0f + 0.5f);
+                    int src_b_i = (int) (src_b * 255.0f + 0.5f);
+
+                    src_r_i = (src_r_i > 255) ? 255 : (src_r_i < 0 ? 0 : src_r_i);
+                    src_g_i = (src_g_i > 255) ? 255 : (src_g_i < 0 ? 0 : src_g_i);
+                    src_b_i = (src_b_i > 255) ? 255 : (src_b_i < 0 ? 0 : src_b_i);
+                    src_a_i = (src_a_i > 255) ? 255 : (src_a_i < 0 ? 0 : src_a_i);
+
+                    int inv_a = 255 - src_a_i;
+
+                    int out_r = (src_r_i * src_a_i + dst_r * inv_a + 128) >> 8;
+                    int out_g = (src_g_i * src_a_i + dst_g * inv_a + 128) >> 8;
+                    int out_b = (src_b_i * src_a_i + dst_b * inv_a + 128) >> 8;
+                    int out_a = src_a_i + ((dst_a * inv_a + 128) >> 8);
+
+                    out_r = (out_r > 255) ? 255 : (out_r < 0 ? 0 : out_r);
+                    out_g = (out_g > 255) ? 255 : (out_g < 0 ? 0 : out_g);
+                    out_b = (out_b > 255) ? 255 : (out_b < 0 ? 0 : out_b);
+                    out_a = (out_a > 255) ? 255 : (out_a < 0 ? 0 : out_a);
+
+                    *pixel_ptr = (Uint32) out_r | ((Uint32) out_g << 8) | ((Uint32) out_b << 16) | ((Uint32) out_a << 24);
+                }
+            }
+
+            color.x += color_step.x;
+            color.y += color_step.y;
+            color.z += color_step.z;
+            color.w += color_step.w;
+
+            if (has_texture)
+            {
+                uv.x += uv_step.x;
+                uv.y += uv_step.y;
+            }
+        }
+    }
+
+    return true;
+}
+
+static void ImGui_ImplSDLRenderer_RasterizeTriangle(
+    ImGui_ImplSDLRenderer_Data* bd,
+    const ImVec2& p0, const ImVec2& p1, const ImVec2& p2,
+    const ImVec2& uv0, const ImVec2& uv1, const ImVec2& uv2,
+    const ImVec4& c0, const ImVec4& c1, const ImVec4& c2,
+    const ImGui_ImplSDLRenderer_TextureSample& texture, const SDL_Rect& clip_rect)
+{
+    float min_x = std::floor(std::min({p0.x, p1.x, p2.x}));
+    float max_x = std::ceil(std::max({p0.x, p1.x, p2.x}));
+    float min_y = std::floor(std::min({p0.y, p1.y, p2.y}));
+    float max_y = std::ceil(std::max({p0.y, p1.y, p2.y}));
+
+    int x0 = std::max((int) min_x, clip_rect.x);
+    int x1 = std::min((int) max_x, clip_rect.x + clip_rect.w - 1);
+    int y0 = std::max((int) min_y, clip_rect.y);
+    int y1 = std::min((int) max_y, clip_rect.y + clip_rect.h - 1);
+
+    if (x0 > x1 || y0 > y1)
+        return;
+
+    float area = (p1.y - p2.y) * (p0.x - p2.x) + (p2.x - p1.x) * (p0.y - p2.y);
+    if (fabsf(area) < 1e-6f)
+        return;
+
+    const float inv_area = 1.0f / area;
+    const bool area_positive = area > 0.0f;
+    const float area_sign = area_positive ? 1.0f : -1.0f;
+
+    // Precompute edge equation coefficients
+    const float edge0_a = p1.y - p2.y;
+    const float edge0_b = p2.x - p1.x;
+    const float edge0_c = p1.x * p2.y - p2.x * p1.y;
+
+    const float edge1_a = p2.y - p0.y;
+    const float edge1_b = p0.x - p2.x;
+    const float edge1_c = p2.x * p0.y - p0.x * p2.y;
+
+    const float w0_num_dx = edge0_a;
+    const float w1_num_dx = edge1_a;
+    const float w2_num_dx = -(w0_num_dx + w1_num_dx);
+
+    const float w0_num_dy = edge0_b;
+    const float w1_num_dy = edge1_b;
+    const float w2_num_dy = -(w0_num_dy + w1_num_dy);
+
+    const float w0_dx = w0_num_dx * inv_area;
+    const float w1_dx = w1_num_dx * inv_area;
+    const float w2_dx = -(w0_dx + w1_dx);
+
+    const float w0_dy = w0_num_dy * inv_area;
+    const float w1_dy = w1_num_dy * inv_area;
+    const float w2_dy = -(w0_dy + w1_dy);
+
+    bool edge0_top_left = ImGui_ImplSDLRenderer_IsTopLeft(p1, p2);
+    bool edge1_top_left = ImGui_ImplSDLRenderer_IsTopLeft(p2, p0);
+    bool edge2_top_left = ImGui_ImplSDLRenderer_IsTopLeft(p0, p1);
+    if (!area_positive)
+    {
+        edge0_top_left = !edge0_top_left;
+        edge1_top_left = !edge1_top_left;
+        edge2_top_left = !edge2_top_left;
+    }
+
+    const bool has_texture = texture.Valid && texture.Pixels != nullptr && texture.Width > 0 && texture.Height > 0 && texture.Pitch > 0;
+    const int frame_width = bd->FrameWidth;
+    Uint32* framebuffer = bd->Framebuffer.data();
+
+    if (frame_width <= 0 || framebuffer == nullptr)
+        return;
+
+    const float px_start = x0 + 0.5f;
+    float py = y0 + 0.5f;
+
+    float w0_num_base = edge0_a * px_start + edge0_b * py + edge0_c;
+    float w1_num_base = edge1_a * px_start + edge1_b * py + edge1_c;
+    float w2_num_base = area - w0_num_base - w1_num_base;
+
+    float w0_base = w0_num_base * inv_area;
+    float w1_base = w1_num_base * inv_area;
+    float w2_base = 1.0f - w0_base - w1_base;
+
+    ImVec4 color_base = ImGui_ImplSDLRenderer_CombineColor(c0, c1, c2, w0_base, w1_base, w2_base);
+    ImVec4 color_dx = ImGui_ImplSDLRenderer_CombineColor(c0, c1, c2, w0_dx, w1_dx, w2_dx);
+    ImVec4 color_dy = ImGui_ImplSDLRenderer_CombineColor(c0, c1, c2, w0_dy, w1_dy, w2_dy);
+
+    ImVec2 uv_base(0.0f, 0.0f);
+    ImVec2 uv_dx(0.0f, 0.0f);
+    ImVec2 uv_dy(0.0f, 0.0f);
+    bool use_bilinear = has_texture;
+    if (has_texture)
+    {
+        uv_base = ImGui_ImplSDLRenderer_CombineUV(uv0, uv1, uv2, w0_base, w1_base, w2_base);
+        uv_dx = ImGui_ImplSDLRenderer_CombineUV(uv0, uv1, uv2, w0_dx, w1_dx, w2_dx);
+        uv_dy = ImGui_ImplSDLRenderer_CombineUV(uv0, uv1, uv2, w0_dy, w1_dy, w2_dy);
+
+        const float u_dx_tex = fabsf(uv_dx.x * texture.Width);
+        const float u_dy_tex = fabsf(uv_dy.x * texture.Width);
+        const float v_dx_tex = fabsf(uv_dx.y * texture.Height);
+        const float v_dy_tex = fabsf(uv_dy.y * texture.Height);
+        const float eps = 1e-4f;
+        if (u_dy_tex < eps && v_dx_tex < eps)
+        {
+            if (fabsf(u_dx_tex - 1.0f) < 1e-3f && fabsf(v_dy_tex - 1.0f) < 1e-3f)
+            {
+                use_bilinear = false;
+            }
+        }
+    }
+
+    for (int y = y0; y <= y1; ++y)
+    {
+        float w0_num = w0_num_base;
+        float w1_num = w1_num_base;
+        float w2_num = w2_num_base;
+
+        float w0 = w0_base;
+        float w1 = w1_base;
+        float w2 = w2_base;
+
+        ImVec4 color = color_base;
+        ImVec2 uv = uv_base;
+
+        Uint32* pixel_ptr = framebuffer + (size_t) y * frame_width + x0;
+
+        for (int x = x0; x <= x1; ++x, ++pixel_ptr)
+        {
+            float w0_test = w0_num * area_sign;
+            float w1_test = w1_num * area_sign;
+            float w2_test = w2_num * area_sign;
+
+            bool inside = true;
+            if (w0_test < 0.0f || (!edge0_top_left && w0_test <= 0.0f))
+                inside = false;
+            else if (w1_test < 0.0f || (!edge1_top_left && w1_test <= 0.0f))
+                inside = false;
+            else if (w2_test < 0.0f || (!edge2_top_left && w2_test <= 0.0f))
+                inside = false;
+
+            if (inside)
+            {
+                float tex_r = 1.0f, tex_g = 1.0f, tex_b = 1.0f, tex_a = 1.0f;
+                if (has_texture)
+                {
+                    if (use_bilinear)
+                    {
+                        ImGui_ImplSDLRenderer_SampleTextureBilinear(texture, uv.x, uv.y, tex_r, tex_g, tex_b, tex_a);
+                    }
+                    else
+                    {
+                        float u = uv.x;
+                        float v = uv.y;
+                        int tx = (int) (u * texture.Width + 0.5f);
+                        int ty = (int) (v * texture.Height + 0.5f);
+                        tx = std::clamp(tx, 0, texture.Width - 1);
+                        ty = std::clamp(ty, 0, texture.Height - 1);
+                        const Uint32 texel = texture.Pixels[static_cast<size_t>(ty) * texture.Pitch + static_cast<size_t>(tx)];
+                        ImGui_ImplSDLRenderer_UnpackTexel(texture, texel, tex_r, tex_g, tex_b, tex_a);
+                    }
+                }
+
+                float src_a = color.w * tex_a;
+                if (src_a > 0.0f)
+                {
+                    float src_r = color.x * tex_r;
+                    float src_g = color.y * tex_g;
+                    float src_b = color.z * tex_b;
+
+                    if (!bd->HasDirtyRegion)
+                    {
+                        bd->MinDirtyX = bd->MaxDirtyX = x;
+                        bd->MinDirtyY = bd->MaxDirtyY = y;
+                        bd->HasDirtyRegion = true;
+                    }
+                    else
+                    {
+                        if (x < bd->MinDirtyX)
+                            bd->MinDirtyX = x;
+                        if (x > bd->MaxDirtyX)
+                            bd->MaxDirtyX = x;
+                        if (y < bd->MinDirtyY)
+                            bd->MinDirtyY = y;
+                        if (y > bd->MaxDirtyY)
+                            bd->MaxDirtyY = y;
+                    }
+
+                    if (src_a >= 1.0f)
+                    {
+                        int r = (int) (src_r * 255.0f + 0.5f);
+                        int g = (int) (src_g * 255.0f + 0.5f);
+                        int b = (int) (src_b * 255.0f + 0.5f);
+                        r = (r > 255) ? 255 : (r < 0 ? 0 : r);
+                        g = (g > 255) ? 255 : (g < 0 ? 0 : g);
+                        b = (b > 255) ? 255 : (b < 0 ? 0 : b);
+
+                        *pixel_ptr = (Uint32) r | ((Uint32) g << 8) | ((Uint32) b << 16) | 0xFF000000;
+                    }
+                    else
+                    {
+                        Uint32 dst = *pixel_ptr;
+                        int dst_r = (int) (dst & 0xFF);
+                        int dst_g = (int) ((dst >> 8) & 0xFF);
+                        int dst_b = (int) ((dst >> 16) & 0xFF);
+                        int dst_a = (int) ((dst >> 24) & 0xFF);
+
+                        int src_a_i = (int) (src_a * 255.0f + 0.5f);
+                        int src_r_i = (int) (src_r * 255.0f + 0.5f);
+                        int src_g_i = (int) (src_g * 255.0f + 0.5f);
+                        int src_b_i = (int) (src_b * 255.0f + 0.5f);
+
+                        src_r_i = (src_r_i > 255) ? 255 : (src_r_i < 0 ? 0 : src_r_i);
+                        src_g_i = (src_g_i > 255) ? 255 : (src_g_i < 0 ? 0 : src_g_i);
+                        src_b_i = (src_b_i > 255) ? 255 : (src_b_i < 0 ? 0 : src_b_i);
+                        src_a_i = (src_a_i > 255) ? 255 : (src_a_i < 0 ? 0 : src_a_i);
+
+                        int inv_a = 255 - src_a_i;
+
+                        int out_r = (src_r_i * src_a_i + dst_r * inv_a + 128) >> 8;
+                        int out_g = (src_g_i * src_a_i + dst_g * inv_a + 128) >> 8;
+                        int out_b = (src_b_i * src_a_i + dst_b * inv_a + 128) >> 8;
+                        int out_a = src_a_i + ((dst_a * inv_a + 128) >> 8);
+
+                        out_r = (out_r > 255) ? 255 : (out_r < 0 ? 0 : out_r);
+                        out_g = (out_g > 255) ? 255 : (out_g < 0 ? 0 : out_g);
+                        out_b = (out_b > 255) ? 255 : (out_b < 0 ? 0 : out_b);
+                        out_a = (out_a > 255) ? 255 : (out_a < 0 ? 0 : out_a);
+
+                        *pixel_ptr = (Uint32) out_r | ((Uint32) out_g << 8) | ((Uint32) out_b << 16) | ((Uint32) out_a << 24);
+                    }
+                }
+            }
+
+            w0_num += w0_num_dx;
+            w1_num += w1_num_dx;
+            w2_num += w2_num_dx;
+
+            w0 += w0_dx;
+            w1 += w1_dx;
+            w2 += w2_dx;
+
+            color.x += color_dx.x;
+            color.y += color_dx.y;
+            color.z += color_dx.z;
+            color.w += color_dx.w;
+
+            if (has_texture)
+            {
+                uv.x += uv_dx.x;
+                uv.y += uv_dx.y;
+            }
+        }
+
+        w0_num_base += w0_num_dy;
+        w1_num_base += w1_num_dy;
+        w2_num_base += w2_num_dy;
+
+        w0_base += w0_dy;
+        w1_base += w1_dy;
+        w2_base += w2_dy;
+
+        color_base.x += color_dy.x;
+        color_base.y += color_dy.y;
+        color_base.z += color_dy.z;
+        color_base.w += color_dy.w;
+
+        if (has_texture)
+        {
+            uv_base.x += uv_dy.x;
+            uv_base.y += uv_dy.y;
+        }
+    }
+}
+
+bool ImGui_ImplSDLRenderer_Init(SDL_Renderer* renderer)
+{
+    ImGuiIO& io = ImGui::GetIO();
+    IM_ASSERT(io.BackendRendererUserData == nullptr && "Already initialized a renderer backend!");
+    IM_ASSERT(renderer != nullptr && "SDL_Renderer not initialized!");
+
+    ImGui_ImplSDLRenderer_Data* bd = IM_NEW(ImGui_ImplSDLRenderer_Data)();
+    io.BackendRendererUserData = (void*) bd;
+    io.BackendRendererName = "imgui_impl_sdlrenderer_legacy_optimized";
+    io.BackendFlags |= ImGuiBackendFlags_RendererHasVtxOffset;
+
+    bd->SDLRenderer = renderer;
+    bd->PerfFrequency = SDL_GetPerformanceFrequency();
+
+    const char* profile_env = SDL_getenv("IMGUI_LEGACY_PROFILE");
+    if (profile_env == nullptr || profile_env[0] == '\0')
+        profile_env = SDL_getenv("SDLREADER_PROFILE_LEGACY");
+    if (profile_env != nullptr && profile_env[0] != '0')
+    {
+        bd->EnableProfiling = true;
+        const char* freq_env = SDL_getenv("IMGUI_LEGACY_PROFILE_FREQ");
+        if (freq_env != nullptr)
+        {
+            int freq = atoi(freq_env);
+            if (freq > 0)
+                bd->ProfileLogFrequency = freq;
+        }
+
+        SDL_Log("ImGui legacy profiling enabled (freq=%d)", bd->ProfileLogFrequency);
+    }
+    else
+    {
+        SDL_Log("ImGui legacy profiling disabled. Set IMGUI_LEGACY_PROFILE=1 to enable logging.");
+    }
+
+    return true;
+}
+
+void ImGui_ImplSDLRenderer_Shutdown()
+{
+    ImGui_ImplSDLRenderer_Data* bd = ImGui_ImplSDLRenderer_GetBackendData();
+    if (bd == nullptr)
+        return;
+
+    ImGui_ImplSDLRenderer_DestroyDeviceObjects();
+
+    ImGuiIO& io = ImGui::GetIO();
+    io.BackendRendererName = nullptr;
+    io.BackendRendererUserData = nullptr;
+    IM_DELETE(bd);
+}
+
+void ImGui_ImplSDLRenderer_NewFrame()
+{
+    ImGui_ImplSDLRenderer_Data* bd = ImGui_ImplSDLRenderer_GetBackendData();
+    IM_ASSERT(bd != nullptr && "Did you call ImGui_ImplSDLRenderer_Init()?");
+
+    if (bd->FontTexture == nullptr)
+        ImGui_ImplSDLRenderer_CreateDeviceObjects();
+}
+
+void ImGui_ImplSDLRenderer_RenderDrawData(ImDrawData* draw_data)
+{
+    ImGui_ImplSDLRenderer_Data* bd = ImGui_ImplSDLRenderer_GetBackendData();
+    if (bd == nullptr)
+        return;
+
+    float renderer_scale_x = 1.0f;
+    float renderer_scale_y = 1.0f;
+    SDL_RenderGetScale(bd->SDLRenderer, &renderer_scale_x, &renderer_scale_y);
+
+    ImVec2 render_scale;
+    render_scale.x = (renderer_scale_x == 1.0f) ? draw_data->FramebufferScale.x : 1.0f;
+    render_scale.y = (renderer_scale_y == 1.0f) ? draw_data->FramebufferScale.y : 1.0f;
+
+    int fb_width = (int) (draw_data->DisplaySize.x * render_scale.x);
+    int fb_height = (int) (draw_data->DisplaySize.y * render_scale.y);
+    if (fb_width <= 0 || fb_height <= 0)
+        return;
+
+    bool framebuffer_resized = (bd->FrameTexture == nullptr) || bd->FrameWidth != fb_width || bd->FrameHeight != fb_height;
+    if (!ImGui_ImplSDLRenderer_EnsureFramebuffer(bd, fb_width, fb_height))
+        return;
+
+    Uint64 frame_hash = ImGui_ImplSDLRenderer_HashDrawData(draw_data);
+    bool geometry_changed = framebuffer_resized || !bd->CachedFrameValid || bd->LastFrameHash != frame_hash;
+    bool used_cached_frame = false;
+
+    struct BackupSDLRendererState
+    {
+        SDL_Rect Viewport;
+        bool ClipEnabled;
+        SDL_Rect ClipRect;
+    };
+
+    BackupSDLRendererState old = {};
+    old.ClipEnabled = SDL_RenderIsClipEnabled(bd->SDLRenderer) == SDL_TRUE;
+    SDL_RenderGetViewport(bd->SDLRenderer, &old.Viewport);
+    SDL_RenderGetClipRect(bd->SDLRenderer, &old.ClipRect);
+
+    ImVec2 clip_off = draw_data->DisplayPos;
+    ImVec2 clip_scale = render_scale;
+
+    ImGui_ImplSDLRenderer_SetupRenderState();
+
+    Uint64 frame_start = 0;
+    if (bd->EnableProfiling)
+        frame_start = SDL_GetPerformanceCounter();
+
+    if (geometry_changed)
+    {
+        for (int n = 0; n < draw_data->CmdListsCount; n++)
+        {
+            const ImDrawList* cmd_list = draw_data->CmdLists[n];
+            const ImDrawVert* vtx_buffer = cmd_list->VtxBuffer.Data;
+            const ImDrawIdx* idx_buffer = cmd_list->IdxBuffer.Data;
+
+            for (int cmd_i = 0; cmd_i < cmd_list->CmdBuffer.Size; cmd_i++)
+            {
+                const ImDrawCmd* pcmd = &cmd_list->CmdBuffer[cmd_i];
+                if (pcmd->UserCallback)
+                {
+                    if (pcmd->UserCallback == ImDrawCallback_ResetRenderState)
+                        ImGui_ImplSDLRenderer_SetupRenderState();
+                    else
+                        pcmd->UserCallback(cmd_list, pcmd);
+                    continue;
+                }
+
+                ImVec2 clip_min = ImVec2((pcmd->ClipRect.x - clip_off.x) * clip_scale.x,
+                                         (pcmd->ClipRect.y - clip_off.y) * clip_scale.y);
+                ImVec2 clip_max = ImVec2((pcmd->ClipRect.z - clip_off.x) * clip_scale.x,
+                                         (pcmd->ClipRect.w - clip_off.y) * clip_scale.y);
+
+                if (clip_max.x <= clip_min.x || clip_max.y <= clip_min.y)
+                    continue;
+
+                SDL_Rect clip_rect;
+                clip_rect.x = (int) std::floor(clip_min.x);
+                clip_rect.y = (int) std::floor(clip_min.y);
+                clip_rect.w = (int) std::ceil(clip_max.x - clip_min.x);
+                clip_rect.h = (int) std::ceil(clip_max.y - clip_min.y);
+
+                clip_rect.x = std::max(clip_rect.x, 0);
+                clip_rect.y = std::max(clip_rect.y, 0);
+                if (clip_rect.x + clip_rect.w > bd->FrameWidth)
+                    clip_rect.w = bd->FrameWidth - clip_rect.x;
+                if (clip_rect.y + clip_rect.h > bd->FrameHeight)
+                    clip_rect.h = bd->FrameHeight - clip_rect.y;
+
+                if (clip_rect.w <= 0 || clip_rect.h <= 0)
+                    continue;
+
+                SDL_RenderSetClipRect(bd->SDLRenderer, &clip_rect);
+
+                SDL_Texture* texture = (SDL_Texture*) pcmd->GetTexID();
+                const ImGui_ImplSDLRenderer_TextureSample tex_sample = ImGui_ImplSDLRenderer_GetTextureSample(bd, texture);
+
+                unsigned int idx = 0;
+                while (idx < pcmd->ElemCount)
+                {
+                    if (idx + 6 <= pcmd->ElemCount &&
+                        ImGui_ImplSDLRenderer_TryRasterizeRect(bd,
+                                                               vtx_buffer,
+                                                               idx_buffer,
+                                                               pcmd->IdxOffset + idx,
+                                                               pcmd->VtxOffset,
+                                                               clip_off,
+                                                               clip_scale,
+                                                               clip_rect,
+                                                               tex_sample))
+                    {
+                        idx += 6;
+                        continue;
+                    }
+
+                    if (idx + 3 > pcmd->ElemCount)
+                        break;
+
+                    const unsigned int index0 = pcmd->VtxOffset + (unsigned int) idx_buffer[pcmd->IdxOffset + idx + 0];
+                    const unsigned int index1 = pcmd->VtxOffset + (unsigned int) idx_buffer[pcmd->IdxOffset + idx + 1];
+                    const unsigned int index2 = pcmd->VtxOffset + (unsigned int) idx_buffer[pcmd->IdxOffset + idx + 2];
+
+                    const ImDrawVert& v0 = vtx_buffer[index0];
+                    const ImDrawVert& v1 = vtx_buffer[index1];
+                    const ImDrawVert& v2 = vtx_buffer[index2];
+
+                    ImVec2 p0 = ImVec2((v0.pos.x - clip_off.x) * clip_scale.x, (v0.pos.y - clip_off.y) * clip_scale.y);
+                    ImVec2 p1 = ImVec2((v1.pos.x - clip_off.x) * clip_scale.x, (v1.pos.y - clip_off.y) * clip_scale.y);
+                    ImVec2 p2 = ImVec2((v2.pos.x - clip_off.x) * clip_scale.x, (v2.pos.y - clip_off.y) * clip_scale.y);
+
+                    ImVec4 c0 = ImGui_ImplSDLRenderer_UnpackColor(v0.col);
+                    ImVec4 c1 = ImGui_ImplSDLRenderer_UnpackColor(v1.col);
+                    ImVec4 c2 = ImGui_ImplSDLRenderer_UnpackColor(v2.col);
+
+                    ImGui_ImplSDLRenderer_RasterizeTriangle(bd, p0, p1, p2, v0.uv, v1.uv, v2.uv, c0, c1, c2, tex_sample, clip_rect);
+
+                    idx += 3;
+                }
+            }
+        }
+    }
+    else
+    {
+        used_cached_frame = true;
+    }
+
+    bd->CachedFrameValid = true;
+    bd->LastFrameHash = frame_hash;
+
+    SDL_RenderSetViewport(bd->SDLRenderer, &old.Viewport);
+    SDL_RenderSetClipRect(bd->SDLRenderer, old.ClipEnabled ? &old.ClipRect : nullptr);
+
+    bool performed_update = false;
+    int dirty_pixels = 0;
+
+    if (bd->FrameTexture)
+    {
+        if (bd->HasDirtyRegion)
+        {
+            int min_x = std::max(0, bd->MinDirtyX);
+            int min_y = std::max(0, bd->MinDirtyY);
+            int max_x = std::min(bd->FrameWidth - 1, bd->MaxDirtyX);
+            int max_y = std::min(bd->FrameHeight - 1, bd->MaxDirtyY);
+
+            int dirty_w = max_x - min_x + 1;
+            int dirty_h = max_y - min_y + 1;
+
+            if (dirty_w > 0 && dirty_h > 0)
+            {
+                SDL_Rect dirty_rect = {min_x, min_y, dirty_w, dirty_h};
+                const Uint32* src = bd->Framebuffer.data() + (size_t) min_y * bd->FrameWidth + min_x;
+                if (SDL_UpdateTexture(bd->FrameTexture, &dirty_rect, src, bd->FrameWidth * (int) sizeof(Uint32)) == 0)
+                {
+                    performed_update = true;
+                    dirty_pixels = dirty_w * dirty_h;
+                }
+            }
+        }
+
+        bd->LastDirtyPixels = performed_update ? dirty_pixels : 0;
+        bd->LastFrameHadWork = performed_update;
+
+        SDL_RenderCopy(bd->SDLRenderer, bd->FrameTexture, nullptr, nullptr);
+    }
+
+    if (bd->EnableProfiling)
+    {
+        Uint64 elapsed = SDL_GetPerformanceCounter() - frame_start;
+        if (++bd->ProfileCounter >= bd->ProfileLogFrequency)
+        {
+            bd->ProfileCounter = 0;
+            double ms = (double) elapsed * 1000.0 / (double) (bd->PerfFrequency ? bd->PerfFrequency : 1);
+            const char* cache_state = used_cached_frame ? "hit" : "miss";
+            SDL_Log("ImGui legacy frame %.3f ms (fb=%dx%d dirty_pixels=%d updated=%s cache=%s)",
+                    ms,
+                    bd->FrameWidth,
+                    bd->FrameHeight,
+                    bd->LastDirtyPixels,
+                    performed_update ? "yes" : "no",
+                    cache_state);
+        }
+    }
+}
+
+bool ImGui_ImplSDLRenderer_CreateFontsTexture()
+{
+    ImGuiIO& io = ImGui::GetIO();
+    ImGui_ImplSDLRenderer_Data* bd = ImGui_ImplSDLRenderer_GetBackendData();
+    IM_ASSERT(bd != nullptr);
+
+    unsigned char* pixels = nullptr;
+    int width = 0, height = 0;
+    io.Fonts->GetTexDataAsRGBA32(&pixels, &width, &height);
+    if (width <= 0 || height <= 0 || pixels == nullptr)
+        return false;
+
+    bd->FontPixels.resize((size_t) width * (size_t) height);
+    memcpy(bd->FontPixels.data(), pixels, (size_t) width * (size_t) height * sizeof(ImU32));
+    bd->FontWidth = width;
+    bd->FontHeight = height;
+
+    if (bd->FontTexture)
+    {
+        SDL_DestroyTexture(bd->FontTexture);
+        bd->FontTexture = nullptr;
+    }
+
+    bd->FontTexture = SDL_CreateTexture(bd->SDLRenderer, SDL_PIXELFORMAT_ABGR8888, SDL_TEXTUREACCESS_STATIC, width, height);
+    if (bd->FontTexture == nullptr)
+    {
+        SDL_Log("Failed to create font texture: %s", SDL_GetError());
+        bd->FontPixels.clear();
+        bd->FontWidth = 0;
+        bd->FontHeight = 0;
+        return false;
+    }
+
+    SDL_UpdateTexture(bd->FontTexture, nullptr, pixels, width * 4);
+    SDL_SetTextureBlendMode(bd->FontTexture, SDL_BLENDMODE_BLEND);
+
+    io.Fonts->SetTexID((ImTextureID) (intptr_t) bd->FontTexture);
+    return true;
+}
+
+void ImGui_ImplSDLRenderer_DestroyFontsTexture()
+{
+    ImGuiIO& io = ImGui::GetIO();
+    ImGui_ImplSDLRenderer_Data* bd = ImGui_ImplSDLRenderer_GetBackendData();
+    if (bd == nullptr)
+        return;
+
+    if (bd->FontTexture)
+    {
+        SDL_DestroyTexture(bd->FontTexture);
+        bd->FontTexture = nullptr;
+    }
+
+    bd->FontPixels.clear();
+    bd->FontWidth = 0;
+    bd->FontHeight = 0;
+    io.Fonts->SetTexID(nullptr);
+}
+
+bool ImGui_ImplSDLRenderer_CreateDeviceObjects()
+{
+    return ImGui_ImplSDLRenderer_CreateFontsTexture();
+}
+
+void ImGui_ImplSDLRenderer_DestroyDeviceObjects()
+{
+    ImGui_ImplSDLRenderer_Data* bd = ImGui_ImplSDLRenderer_GetBackendData();
+    if (bd == nullptr)
+        return;
+
+    ImGui_ImplSDLRenderer_DestroyFontsTexture();
+
+    if (bd->FrameTexture)
+    {
+        SDL_DestroyTexture(bd->FrameTexture);
+        bd->FrameTexture = nullptr;
+    }
+
+    bd->Framebuffer.clear();
+    bd->FrameWidth = 0;
+    bd->FrameHeight = 0;
+    bd->HasDirtyRegion = false;
+    bd->TextureCache.clear();
+}
+
+#endif // SDL_VERSION_ATLEAST(2,0,17)
