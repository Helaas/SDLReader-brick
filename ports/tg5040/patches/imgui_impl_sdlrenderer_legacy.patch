diff --git a/backends/imgui_impl_sdlrenderer.cpp b/backends/imgui_impl_sdlrenderer.cpp
index 87381f2..b42c95c 100644
--- a/backends/imgui_impl_sdlrenderer.cpp
+++ b/backends/imgui_impl_sdlrenderer.cpp
@@ -24,33 +24,41 @@
 //  2021-10-06: Backup and restore modified ClipRect/Viewport.
 //  2021-09-21: Initial version.

-#include "imgui.h"
 #include "imgui_impl_sdlrenderer.h"
+#include "imgui.h"
 #if defined(_MSC_VER) && _MSC_VER <= 1500 // MSVC 2008 or earlier
-#include <stddef.h>     // intptr_t
+#include <stddef.h>                       // intptr_t
 #else
-#include <stdint.h>     // intptr_t
+#include <stdint.h> // intptr_t
 #endif

+#include <algorithm>
+#include <cmath>
+#include <cstdlib>
+#include <cstring>
+#include <unordered_map>
+#include <vector>
+
 // SDL
 #include <SDL.h>
-#if !SDL_VERSION_ATLEAST(2,0,17)
-#error This backend requires SDL 2.0.17+ because of SDL_RenderGeometry() function
-#endif
+#if SDL_VERSION_ATLEAST(2, 0, 17)

 // SDL_Renderer data
 struct ImGui_ImplSDLRenderer_Data
 {
-    SDL_Renderer*   SDLRenderer;
-    SDL_Texture*    FontTexture;
-    ImGui_ImplSDLRenderer_Data() { memset((void*)this, 0, sizeof(*this)); }
+    SDL_Renderer* SDLRenderer;
+    SDL_Texture* FontTexture;
+    ImGui_ImplSDLRenderer_Data()
+    {
+        memset((void*) this, 0, sizeof(*this));
+    }
 };

 // Backend data stored in io.BackendRendererUserData to allow support for multiple Dear ImGui contexts
 // It is STRONGLY preferred that you use docking branch with multi-viewports (== single Dear ImGui context + multiple windows) instead of multiple Dear ImGui contexts.
 static ImGui_ImplSDLRenderer_Data* ImGui_ImplSDLRenderer_GetBackendData()
 {
-    return ImGui::GetCurrentContext() ? (ImGui_ImplSDLRenderer_Data*)ImGui::GetIO().BackendRendererUserData : nullptr;
+    return ImGui::GetCurrentContext() ? (ImGui_ImplSDLRenderer_Data*) ImGui::GetIO().BackendRendererUserData : nullptr;
 }

 // Functions
@@ -62,9 +70,9 @@ bool ImGui_ImplSDLRenderer_Init(SDL_Renderer* renderer)

     // Setup backend capabilities flags
     ImGui_ImplSDLRenderer_Data* bd = IM_NEW(ImGui_ImplSDLRenderer_Data)();
-    io.BackendRendererUserData = (void*)bd;
+    io.BackendRendererUserData = (void*) bd;
     io.BackendRendererName = "imgui_impl_sdlrenderer";
-    io.BackendFlags |= ImGuiBackendFlags_RendererHasVtxOffset;  // We can honor the ImDrawCmd::VtxOffset field, allowing for large meshes.
+    io.BackendFlags |= ImGuiBackendFlags_RendererHasVtxOffset; // We can honor the ImDrawCmd::VtxOffset field, allowing for large meshes.

     bd->SDLRenderer = renderer;

@@ -86,12 +94,12 @@ void ImGui_ImplSDLRenderer_Shutdown()

 static void ImGui_ImplSDLRenderer_SetupRenderState()
 {
-	ImGui_ImplSDLRenderer_Data* bd = ImGui_ImplSDLRenderer_GetBackendData();
+    ImGui_ImplSDLRenderer_Data* bd = ImGui_ImplSDLRenderer_GetBackendData();

-	// Clear out any viewports and cliprect set by the user
+    // Clear out any viewports and cliprect set by the user
     // FIXME: Technically speaking there are lots of other things we could backup/setup/restore during our render process.
-	SDL_RenderSetViewport(bd->SDLRenderer, nullptr);
-	SDL_RenderSetClipRect(bd->SDLRenderer, nullptr);
+    SDL_RenderSetViewport(bd->SDLRenderer, nullptr);
+    SDL_RenderSetClipRect(bd->SDLRenderer, nullptr);
 }

 void ImGui_ImplSDLRenderer_NewFrame()
@@ -105,39 +113,39 @@ void ImGui_ImplSDLRenderer_NewFrame()

 void ImGui_ImplSDLRenderer_RenderDrawData(ImDrawData* draw_data)
 {
-	ImGui_ImplSDLRenderer_Data* bd = ImGui_ImplSDLRenderer_GetBackendData();
+    ImGui_ImplSDLRenderer_Data* bd = ImGui_ImplSDLRenderer_GetBackendData();

-	// If there's a scale factor set by the user, use that instead
+    // If there's a scale factor set by the user, use that instead
     // If the user has specified a scale factor to SDL_Renderer already via SDL_RenderSetScale(), SDL will scale whatever we pass
     // to SDL_RenderGeometryRaw() by that scale factor. In that case we don't want to be also scaling it ourselves here.
     float rsx = 1.0f;
-	float rsy = 1.0f;
-	SDL_RenderGetScale(bd->SDLRenderer, &rsx, &rsy);
+    float rsy = 1.0f;
+    SDL_RenderGetScale(bd->SDLRenderer, &rsx, &rsy);
     ImVec2 render_scale;
-	render_scale.x = (rsx == 1.0f) ? draw_data->FramebufferScale.x : 1.0f;
-	render_scale.y = (rsy == 1.0f) ? draw_data->FramebufferScale.y : 1.0f;
+    render_scale.x = (rsx == 1.0f) ? draw_data->FramebufferScale.x : 1.0f;
+    render_scale.y = (rsy == 1.0f) ? draw_data->FramebufferScale.y : 1.0f;

-	// Avoid rendering when minimized, scale coordinates for retina displays (screen coordinates != framebuffer coordinates)
-	int fb_width = (int)(draw_data->DisplaySize.x * render_scale.x);
-	int fb_height = (int)(draw_data->DisplaySize.y * render_scale.y);
-	if (fb_width == 0 || fb_height == 0)
-		return;
+    // Avoid rendering when minimized, scale coordinates for retina displays (screen coordinates != framebuffer coordinates)
+    int fb_width = (int) (draw_data->DisplaySize.x * render_scale.x);
+    int fb_height = (int) (draw_data->DisplaySize.y * render_scale.y);
+    if (fb_width == 0 || fb_height == 0)
+        return;

     // Backup SDL_Renderer state that will be modified to restore it afterwards
     struct BackupSDLRendererState
     {
-        SDL_Rect    Viewport;
-        bool        ClipEnabled;
-        SDL_Rect    ClipRect;
+        SDL_Rect Viewport;
+        bool ClipEnabled;
+        SDL_Rect ClipRect;
     };
     BackupSDLRendererState old = {};
     old.ClipEnabled = SDL_RenderIsClipEnabled(bd->SDLRenderer) == SDL_TRUE;
     SDL_RenderGetViewport(bd->SDLRenderer, &old.Viewport);
     SDL_RenderGetClipRect(bd->SDLRenderer, &old.ClipRect);

-	// Will project scissor/clipping rectangles into framebuffer space
-	ImVec2 clip_off = draw_data->DisplayPos;         // (0,0) unless using multi-viewports
-	ImVec2 clip_scale = render_scale;
+    // Will project scissor/clipping rectangles into framebuffer space
+    ImVec2 clip_off = draw_data->DisplayPos; // (0,0) unless using multi-viewports
+    ImVec2 clip_scale = render_scale;

     // Render command lists
     ImGui_ImplSDLRenderer_SetupRenderState();
@@ -164,32 +172,44 @@ void ImGui_ImplSDLRenderer_RenderDrawData(ImDrawData* draw_data)
                 // Project scissor/clipping rectangles into framebuffer space
                 ImVec2 clip_min((pcmd->ClipRect.x - clip_off.x) * clip_scale.x, (pcmd->ClipRect.y - clip_off.y) * clip_scale.y);
                 ImVec2 clip_max((pcmd->ClipRect.z - clip_off.x) * clip_scale.x, (pcmd->ClipRect.w - clip_off.y) * clip_scale.y);
-                if (clip_min.x < 0.0f) { clip_min.x = 0.0f; }
-                if (clip_min.y < 0.0f) { clip_min.y = 0.0f; }
-                if (clip_max.x > (float)fb_width) { clip_max.x = (float)fb_width; }
-                if (clip_max.y > (float)fb_height) { clip_max.y = (float)fb_height; }
+                if (clip_min.x < 0.0f)
+                {
+                    clip_min.x = 0.0f;
+                }
+                if (clip_min.y < 0.0f)
+                {
+                    clip_min.y = 0.0f;
+                }
+                if (clip_max.x > (float) fb_width)
+                {
+                    clip_max.x = (float) fb_width;
+                }
+                if (clip_max.y > (float) fb_height)
+                {
+                    clip_max.y = (float) fb_height;
+                }
                 if (clip_max.x <= clip_min.x || clip_max.y <= clip_min.y)
                     continue;

-                SDL_Rect r = { (int)(clip_min.x), (int)(clip_min.y), (int)(clip_max.x - clip_min.x), (int)(clip_max.y - clip_min.y) };
+                SDL_Rect r = {(int) (clip_min.x), (int) (clip_min.y), (int) (clip_max.x - clip_min.x), (int) (clip_max.y - clip_min.y)};
                 SDL_RenderSetClipRect(bd->SDLRenderer, &r);

-                const float* xy = (const float*)(const void*)((const char*)(vtx_buffer + pcmd->VtxOffset) + IM_OFFSETOF(ImDrawVert, pos));
-                const float* uv = (const float*)(const void*)((const char*)(vtx_buffer + pcmd->VtxOffset) + IM_OFFSETOF(ImDrawVert, uv));
-#if SDL_VERSION_ATLEAST(2,0,19)
-                const SDL_Color* color = (const SDL_Color*)(const void*)((const char*)(vtx_buffer + pcmd->VtxOffset) + IM_OFFSETOF(ImDrawVert, col)); // SDL 2.0.19+
-#else
-                const int* color = (const int*)(const void*)((const char*)(vtx_buffer + pcmd->VtxOffset) + IM_OFFSETOF(ImDrawVert, col)); // SDL 2.0.17 and 2.0.18
-#endif
+                const float* xy = (const float*) (const void*) ((const char*) (vtx_buffer + pcmd->VtxOffset) + IM_OFFSETOF(ImDrawVert, pos));
+                const float* uv = (const float*) (const void*) ((const char*) (vtx_buffer + pcmd->VtxOffset) + IM_OFFSETOF(ImDrawVert, uv));
+                #if SDL_VERSION_ATLEAST(2, 0, 19)
+                const SDL_Color* color = (const SDL_Color*) (const void*) ((const char*) (vtx_buffer + pcmd->VtxOffset) + IM_OFFSETOF(ImDrawVert, col)); // SDL 2.0.19+
+                #else
+                const int* color = (const int*) (const void*) ((const char*) (vtx_buffer + pcmd->VtxOffset) + IM_OFFSETOF(ImDrawVert, col)); // SDL 2.0.17 and 2.0.18
+                #endif

                 // Bind texture, Draw
-				SDL_Texture* tex = (SDL_Texture*)pcmd->GetTexID();
+                SDL_Texture* tex = (SDL_Texture*) pcmd->GetTexID();
                 SDL_RenderGeometryRaw(bd->SDLRenderer, tex,
-                    xy, (int)sizeof(ImDrawVert),
-                    color, (int)sizeof(ImDrawVert),
-                    uv, (int)sizeof(ImDrawVert),
-                    cmd_list->VtxBuffer.Size - pcmd->VtxOffset,
-                    idx_buffer + pcmd->IdxOffset, pcmd->ElemCount, sizeof(ImDrawIdx));
+                                      xy, (int) sizeof(ImDrawVert),
+                                      color, (int) sizeof(ImDrawVert),
+                                      uv, (int) sizeof(ImDrawVert),
+                                      cmd_list->VtxBuffer.Size - pcmd->VtxOffset,
+                                      idx_buffer + pcmd->IdxOffset, pcmd->ElemCount, sizeof(ImDrawIdx));
             }
         }
     }
@@ -208,7 +228,7 @@ bool ImGui_ImplSDLRenderer_CreateFontsTexture()
     // Build texture atlas
     unsigned char* pixels;
     int width, height;
-    io.Fonts->GetTexDataAsRGBA32(&pixels, &width, &height);   // Load as RGBA 32-bit (75% of the memory is wasted, but default font is so small) because it is more likely to be compatible with user's existing shaders. If your ImTextureId represent a higher-level concept than just a GL texture id, consider calling GetTexDataAsAlpha8() instead to save on GPU memory.
+    io.Fonts->GetTexDataAsRGBA32(&pixels, &width, &height); // Load as RGBA 32-bit (75% of the memory is wasted, but default font is so small) because it is more likely to be compatible with user's existing shaders. If your ImTextureId represent a higher-level concept than just a GL texture id, consider calling GetTexDataAsAlpha8() instead to save on GPU memory.

     // Upload texture to graphics system
     // (Bilinear sampling is required by default. Set 'io.Fonts->Flags |= ImFontAtlasFlags_NoBakedLines' or 'style.AntiAliasedLinesUseTex = false' to allow point/nearest sampling)
@@ -223,7 +243,7 @@ bool ImGui_ImplSDLRenderer_CreateFontsTexture()
     SDL_SetTextureScaleMode(bd->FontTexture, SDL_ScaleModeLinear);

     // Store our identifier
-    io.Fonts->SetTexID((ImTextureID)(intptr_t)bd->FontTexture);
+    io.Fonts->SetTexID((ImTextureID) (intptr_t) bd->FontTexture);

     return true;
 }
@@ -249,3 +269,900 @@ void ImGui_ImplSDLRenderer_DestroyDeviceObjects()
 {
     ImGui_ImplSDLRenderer_DestroyFontsTexture();
 }
+#else
+
+struct ImGui_ImplSDLRenderer_TextureCacheEntry
+{
+    std::vector<Uint32> Pixels;
+    int Width = 0;
+    int Height = 0;
+    int Pitch = 0;
+    Uint32 Format = 0;
+    Uint8 RShift = 0;
+    Uint8 GShift = 0;
+    Uint8 BShift = 0;
+    Uint8 AShift = 0;
+    Uint32 RMask = 0;
+    Uint32 GMask = 0;
+    Uint32 BMask = 0;
+    Uint32 AMask = 0;
+    float RScale = 1.0f;
+    float GScale = 1.0f;
+    float BScale = 1.0f;
+    float AScale = 1.0f;
+    bool Valid = false;
+    bool PermanentFailure = false;
+};
+
+struct ImGui_ImplSDLRenderer_TextureSample
+{
+    const Uint32* Pixels = nullptr;
+    int Width = 0;
+    int Height = 0;
+    int Pitch = 0;
+    Uint8 RShift = 0;
+    Uint8 GShift = 0;
+    Uint8 BShift = 0;
+    Uint8 AShift = 0;
+    Uint32 RMask = 0;
+    Uint32 GMask = 0;
+    Uint32 BMask = 0;
+    Uint32 AMask = 0;
+    float RScale = 1.0f;
+    float GScale = 1.0f;
+    float BScale = 1.0f;
+    float AScale = 1.0f;
+    bool Valid = false;
+};
+
+struct ImGui_ImplSDLRenderer_Data
+{
+    SDL_Renderer* SDLRenderer;
+    SDL_Texture* FontTexture;
+    SDL_Texture* FrameTexture;
+    std::vector<ImU32> FontPixels;
+    int FontWidth;
+    int FontHeight;
+    std::vector<Uint32> Framebuffer;
+    int FrameWidth;
+    int FrameHeight;
+    int MinDirtyX, MinDirtyY, MaxDirtyX, MaxDirtyY;
+    bool HasDirtyRegion;
+    bool EnableProfiling;
+    int ProfileLogFrequency;
+    int ProfileCounter;
+    Uint64 PerfFrequency;
+    int LastDirtyPixels;
+    bool LastFrameHadWork;
+    bool CachedFrameValid;
+    Uint64 LastFrameHash;
+    std::unordered_map<SDL_Texture*, ImGui_ImplSDLRenderer_TextureCacheEntry> TextureCache;
+
+    ImGui_ImplSDLRenderer_Data()
+    : SDLRenderer(nullptr), FontTexture(nullptr), FrameTexture(nullptr), FontWidth(0), FontHeight(0), FrameWidth(0), FrameHeight(0), MinDirtyX(0), MinDirtyY(0), MaxDirtyX(0), MaxDirtyY(0), HasDirtyRegion(false), EnableProfiling(false), ProfileLogFrequency(120), ProfileCounter(0), PerfFrequency(0), LastDirtyPixels(0), LastFrameHadWork(false), CachedFrameValid(false), LastFrameHash(0)
+    {
+    }
+};
+
+static ImGui_ImplSDLRenderer_Data* ImGui_ImplSDLRenderer_GetBackendData()
+{
+    return ImGui::GetCurrentContext() ? (ImGui_ImplSDLRenderer_Data*) ImGui::GetIO().BackendRendererUserData : nullptr;
+}
+
+static void ImGui_ImplSDLRenderer_SetupRenderState()
+{
+    ImGui_ImplSDLRenderer_Data* bd = ImGui_ImplSDLRenderer_GetBackendData();
+    SDL_RenderSetViewport(bd->SDLRenderer, nullptr);
+    SDL_RenderSetClipRect(bd->SDLRenderer, nullptr);
+}
+
+static Uint64 ImGui_ImplSDLRenderer_HashDrawData(const ImDrawData* draw_data)
+{
+    const Uint64 fnv_offset = 1469598103934665603ULL;
+    const Uint64 fnv_prime = 1099511628211ULL;
+    Uint64 hash = fnv_offset;
+
+    auto hash_bytes = [&](const void* data, size_t size)
+    {
+        const unsigned char* bytes = static_cast<const unsigned char*>(data);
+        for (size_t i = 0; i < size; ++i)
+        {
+            hash ^= bytes[i];
+            hash *= fnv_prime;
+        }
+    };
+
+    hash_bytes(&draw_data->DisplayPos, sizeof(draw_data->DisplayPos));
+    hash_bytes(&draw_data->DisplaySize, sizeof(draw_data->DisplaySize));
+    hash_bytes(&draw_data->FramebufferScale, sizeof(draw_data->FramebufferScale));
+    hash_bytes(&draw_data->CmdListsCount, sizeof(draw_data->CmdListsCount));
+
+    for (int n = 0; n < draw_data->CmdListsCount; ++n)
+    {
+        const ImDrawList* cmd_list = draw_data->CmdLists[n];
+        hash_bytes(&cmd_list->VtxBuffer.Size, sizeof(cmd_list->VtxBuffer.Size));
+        if (cmd_list->VtxBuffer.Size > 0)
+            hash_bytes(cmd_list->VtxBuffer.Data, (size_t) cmd_list->VtxBuffer.Size * sizeof(ImDrawVert));
+
+        hash_bytes(&cmd_list->IdxBuffer.Size, sizeof(cmd_list->IdxBuffer.Size));
+        if (cmd_list->IdxBuffer.Size > 0)
+            hash_bytes(cmd_list->IdxBuffer.Data, (size_t) cmd_list->IdxBuffer.Size * sizeof(ImDrawIdx));
+
+        hash_bytes(&cmd_list->CmdBuffer.Size, sizeof(cmd_list->CmdBuffer.Size));
+        for (int cmd_i = 0; cmd_i < cmd_list->CmdBuffer.Size; ++cmd_i)
+        {
+            const ImDrawCmd& cmd = cmd_list->CmdBuffer[cmd_i];
+            hash_bytes(&cmd.ClipRect, sizeof(cmd.ClipRect));
+            hash_bytes(&cmd.ElemCount, sizeof(cmd.ElemCount));
+            hash_bytes(&cmd.IdxOffset, sizeof(cmd.IdxOffset));
+            hash_bytes(&cmd.VtxOffset, sizeof(cmd.VtxOffset));
+
+            const uintptr_t tex_id = (uintptr_t) cmd.GetTexID();
+            hash_bytes(&tex_id, sizeof(tex_id));
+
+            hash_bytes(&cmd.UserCallback, sizeof(cmd.UserCallback));
+            hash_bytes(&cmd.UserCallbackData, sizeof(cmd.UserCallbackData));
+        }
+    }
+
+    return hash;
+}
+
+static int ImGui_ImplSDLRenderer_CalcShift(Uint32 mask)
+{
+    if (mask == 0)
+        return 0;
+    int shift = 0;
+    while ((mask & 1u) == 0u)
+    {
+        mask >>= 1;
+        shift++;
+    }
+    return shift;
+}
+
+static float ImGui_ImplSDLRenderer_CalcScale(Uint32 mask, int shift)
+{
+    if (mask == 0)
+        return 1.0f;
+    Uint32 component_max = mask >> shift;
+    if (component_max == 0)
+        return 1.0f;
+    return 1.0f / static_cast<float>(component_max);
+}
+
+static bool ImGui_ImplSDLRenderer_LoadTextureToCache(SDL_Texture* texture,
+                                                     int width,
+                                                     int height,
+                                                     Uint32 format,
+                                                     ImGui_ImplSDLRenderer_TextureCacheEntry& entry)
+{
+    if (texture == nullptr || width <= 0 || height <= 0)
+        return false;
+
+    void* pixels = nullptr;
+    int pitch = 0;
+    if (SDL_LockTexture(texture, nullptr, &pixels, &pitch) != 0)
+        return false;
+
+    entry.Pixels.resize(static_cast<size_t>(width) * static_cast<size_t>(height));
+    const Uint8* src_bytes = static_cast<const Uint8*>(pixels);
+    for (int y = 0; y < height; ++y)
+    {
+        const Uint32* row = reinterpret_cast<const Uint32*>(src_bytes + static_cast<size_t>(y) * pitch);
+        std::copy(row, row + width, entry.Pixels.begin() + static_cast<size_t>(y) * width);
+    }
+    SDL_UnlockTexture(texture);
+
+    entry.Width = width;
+    entry.Height = height;
+    entry.Pitch = width;
+    entry.Format = format;
+
+    int bpp = 0;
+    Uint32 rmask = 0, gmask = 0, bmask = 0, amask = 0;
+    if (!SDL_PixelFormatEnumToMasks(format, &bpp, &rmask, &gmask, &bmask, &amask) || bpp != 32)
+    {
+        rmask = 0x00FF0000u;
+        gmask = 0x0000FF00u;
+        bmask = 0x000000FFu;
+        amask = 0xFF000000u;
+    }
+
+    entry.RMask = rmask;
+    entry.GMask = gmask;
+    entry.BMask = bmask;
+    entry.AMask = amask;
+    entry.RShift = (Uint8) ImGui_ImplSDLRenderer_CalcShift(rmask);
+    entry.GShift = (Uint8) ImGui_ImplSDLRenderer_CalcShift(gmask);
+    entry.BShift = (Uint8) ImGui_ImplSDLRenderer_CalcShift(bmask);
+    entry.AShift = (Uint8) ImGui_ImplSDLRenderer_CalcShift(amask);
+    entry.RScale = ImGui_ImplSDLRenderer_CalcScale(rmask, entry.RShift);
+    entry.GScale = ImGui_ImplSDLRenderer_CalcScale(gmask, entry.GShift);
+    entry.BScale = ImGui_ImplSDLRenderer_CalcScale(bmask, entry.BShift);
+    entry.AScale = ImGui_ImplSDLRenderer_CalcScale(amask, entry.AShift);
+    entry.Valid = true;
+    entry.PermanentFailure = false;
+    return true;
+}
+
+static ImGui_ImplSDLRenderer_TextureSample ImGui_ImplSDLRenderer_GetTextureSample(ImGui_ImplSDLRenderer_Data* bd, SDL_Texture* texture)
+{
+    ImGui_ImplSDLRenderer_TextureSample sample;
+    if (texture == nullptr)
+        return sample;
+
+    if (texture == bd->FontTexture && !bd->FontPixels.empty() && bd->FontWidth > 0 && bd->FontHeight > 0)
+    {
+        sample.Pixels = bd->FontPixels.data();
+        sample.Width = bd->FontWidth;
+        sample.Height = bd->FontHeight;
+        sample.Pitch = bd->FontWidth;
+        sample.RMask = ((Uint32) 0xFFu) << IM_COL32_R_SHIFT;
+        sample.GMask = ((Uint32) 0xFFu) << IM_COL32_G_SHIFT;
+        sample.BMask = ((Uint32) 0xFFu) << IM_COL32_B_SHIFT;
+        sample.AMask = ((Uint32) 0xFFu) << IM_COL32_A_SHIFT;
+        sample.RShift = IM_COL32_R_SHIFT;
+        sample.GShift = IM_COL32_G_SHIFT;
+        sample.BShift = IM_COL32_B_SHIFT;
+        sample.AShift = IM_COL32_A_SHIFT;
+        sample.RScale = 1.0f / 255.0f;
+        sample.GScale = 1.0f / 255.0f;
+        sample.BScale = 1.0f / 255.0f;
+        sample.AScale = 1.0f / 255.0f;
+        sample.Valid = true;
+        return sample;
+    }
+
+    Uint32 format = 0;
+    int access = 0;
+    int width = 0;
+    int height = 0;
+    if (SDL_QueryTexture(texture, &format, &access, &width, &height) != 0 || width <= 0 || height <= 0)
+        return sample;
+
+    auto it = bd->TextureCache.find(texture);
+    if (it == bd->TextureCache.end())
+    {
+        it = bd->TextureCache.emplace(texture, ImGui_ImplSDLRenderer_TextureCacheEntry{}).first;
+    }
+
+    ImGui_ImplSDLRenderer_TextureCacheEntry& entry = it->second;
+    const bool signature_matches = entry.Valid && entry.Width == width && entry.Height == height && entry.Format == format;
+    if (entry.PermanentFailure && signature_matches)
+        return sample;
+
+    if (!signature_matches)
+    {
+        entry.Valid = false;
+        entry.PermanentFailure = false;
+    }
+
+    if (!entry.Valid)
+    {
+        if (!ImGui_ImplSDLRenderer_LoadTextureToCache(texture, width, height, format, entry))
+        {
+            if (!entry.PermanentFailure)
+            {
+                entry.Pixels.clear();
+                entry.Width = width;
+                entry.Height = height;
+                entry.Pitch = 0;
+                entry.Format = format;
+                entry.Valid = false;
+                entry.PermanentFailure = true;
+                SDL_Log("ImGui legacy renderer: unable to sample texture %p (format=0x%x, access=%d): %s",
+                        (void*) texture, format, access, SDL_GetError());
+            }
+            return sample;
+        }
+    }
+
+    if (!entry.Valid || entry.Pixels.empty())
+        return sample;
+
+    sample.Pixels = entry.Pixels.data();
+    sample.Width = entry.Width;
+    sample.Height = entry.Height;
+    sample.Pitch = entry.Pitch;
+    sample.RMask = entry.RMask;
+    sample.GMask = entry.GMask;
+    sample.BMask = entry.BMask;
+    sample.AMask = entry.AMask;
+    sample.RShift = entry.RShift;
+    sample.GShift = entry.GShift;
+    sample.BShift = entry.BShift;
+    sample.AShift = entry.AShift;
+    sample.RScale = entry.RScale;
+    sample.GScale = entry.GScale;
+    sample.BScale = entry.BScale;
+    sample.AScale = entry.AScale;
+    sample.Valid = true;
+    return sample;
+}
+
+static bool ImGui_ImplSDLRenderer_EnsureFramebuffer(ImGui_ImplSDLRenderer_Data* bd, int width, int height)
+{
+    if (width <= 0 || height <= 0)
+        return false;
+
+    if (bd->FrameWidth != width || bd->FrameHeight != height || bd->FrameTexture == nullptr)
+    {
+        if (bd->FrameTexture)
+        {
+            SDL_DestroyTexture(bd->FrameTexture);
+            bd->FrameTexture = nullptr;
+        }
+
+        bd->Framebuffer.resize((size_t) width * (size_t) height);
+        bd->FrameWidth = width;
+        bd->FrameHeight = height;
+
+        bd->FrameTexture = SDL_CreateTexture(bd->SDLRenderer, SDL_PIXELFORMAT_ABGR8888, SDL_TEXTUREACCESS_STREAMING, width, height);
+        if (bd->FrameTexture == nullptr)
+        {
+            SDL_Log("Failed to create ImGui legacy framebuffer: %s", SDL_GetError());
+            bd->Framebuffer.clear();
+            bd->FrameWidth = 0;
+            bd->FrameHeight = 0;
+            return false;
+        }
+
+        SDL_SetTextureBlendMode(bd->FrameTexture, SDL_BLENDMODE_BLEND);
+        // Clear entire buffer on resize
+        std::fill(bd->Framebuffer.begin(), bd->Framebuffer.end(), 0u);
+        bd->CachedFrameValid = false;
+
+        if (!bd->Framebuffer.empty())
+        {
+            SDL_UpdateTexture(bd->FrameTexture, nullptr, bd->Framebuffer.data(), width * (int) sizeof(Uint32));
+        }
+    }
+    else if (bd->HasDirtyRegion)
+    {
+        // Only clear the dirty region from previous frame
+        int dirty_w = bd->MaxDirtyX - bd->MinDirtyX + 1;
+        int dirty_h = bd->MaxDirtyY - bd->MinDirtyY + 1;
+
+        if (dirty_w > 0 && dirty_h > 0)
+        {
+            for (int y = bd->MinDirtyY; y <= bd->MaxDirtyY && y < bd->FrameHeight; ++y)
+            {
+                size_t start_idx = (size_t) y * bd->FrameWidth + bd->MinDirtyX;
+                size_t count = std::min(dirty_w, bd->FrameWidth - bd->MinDirtyX);
+                std::fill(bd->Framebuffer.begin() + start_idx, bd->Framebuffer.begin() + start_idx + count, 0u);
+            }
+        }
+    }
+
+    // Reset dirty region tracking
+    bd->HasDirtyRegion = false;
+    bd->MinDirtyX = bd->FrameWidth;
+    bd->MinDirtyY = bd->FrameHeight;
+    bd->MaxDirtyX = -1;
+    bd->MaxDirtyY = -1;
+    bd->LastDirtyPixels = 0;
+    bd->LastFrameHadWork = false;
+
+    return true;
+}
+
+static ImVec4 ImGui_ImplSDLRenderer_UnpackColor(ImU32 col)
+{
+    const float inv255 = 1.0f / 255.0f;
+    return ImVec4(
+        ((col >> IM_COL32_R_SHIFT) & 0xFF) * inv255,
+                  ((col >> IM_COL32_G_SHIFT) & 0xFF) * inv255,
+                  ((col >> IM_COL32_B_SHIFT) & 0xFF) * inv255,
+                  ((col >> IM_COL32_A_SHIFT) & 0xFF) * inv255);
+}
+
+static void ImGui_ImplSDLRenderer_RasterizeTriangle(
+    ImGui_ImplSDLRenderer_Data* bd,
+    const ImVec2& p0, const ImVec2& p1, const ImVec2& p2,
+    const ImVec2& uv0, const ImVec2& uv1, const ImVec2& uv2,
+    const ImVec4& c0, const ImVec4& c1, const ImVec4& c2,
+    const ImGui_ImplSDLRenderer_TextureSample& texture, const SDL_Rect& clip_rect)
+{
+    float min_x = std::floor(std::min({p0.x, p1.x, p2.x}));
+    float max_x = std::ceil(std::max({p0.x, p1.x, p2.x}));
+    float min_y = std::floor(std::min({p0.y, p1.y, p2.y}));
+    float max_y = std::ceil(std::max({p0.y, p1.y, p2.y}));
+
+    int x0 = std::max((int) min_x, clip_rect.x);
+    int x1 = std::min((int) max_x, clip_rect.x + clip_rect.w - 1);
+    int y0 = std::max((int) min_y, clip_rect.y);
+    int y1 = std::min((int) max_y, clip_rect.y + clip_rect.h - 1);
+
+    if (x0 > x1 || y0 > y1)
+        return;
+
+    float area = (p1.y - p2.y) * (p0.x - p2.x) + (p2.x - p1.x) * (p0.y - p2.y);
+    if (fabsf(area) < 1e-6f)
+        return;
+    float inv_area = 1.0f / area;
+    bool area_positive = area > 0.0f;
+
+    // Precompute edge equation coefficients
+    float edge0_a = p1.y - p2.y;
+    float edge0_b = p2.x - p1.x;
+    float edge0_c = p1.x * p2.y - p2.x * p1.y;
+
+    float edge1_a = p2.y - p0.y;
+    float edge1_b = p0.x - p2.x;
+    float edge1_c = p2.x * p0.y - p0.x * p2.y;
+
+    const bool has_texture = texture.Valid && texture.Pixels != nullptr && texture.Width > 0 && texture.Height > 0 && texture.Pitch > 0;
+    const int frame_width = bd->FrameWidth;
+    Uint32* framebuffer = bd->Framebuffer.data();
+
+    if (frame_width <= 0 || framebuffer == nullptr)
+        return;
+
+    // Scanline rasterization with incremental barycentric coordinates
+    for (int y = y0; y <= y1; ++y)
+    {
+        float py = y + 0.5f;
+
+        // Calculate barycentric coordinates at start of scanline
+        float px_start = x0 + 0.5f;
+        float w0_row = edge0_a * px_start + edge0_b * py + edge0_c;
+        float w1_row = edge1_a * px_start + edge1_b * py + edge1_c;
+
+        Uint32* pixel_ptr = framebuffer + (size_t) y * frame_width + x0;
+
+        for (int x = x0; x <= x1; ++x, w0_row += edge0_a, w1_row += edge1_a, ++pixel_ptr)
+        {
+            float w0 = w0_row;
+            float w1 = w1_row;
+            float w2 = area - w0 - w1;
+
+            // Inside test
+            if (area_positive)
+            {
+                if (w0 < 0.0f || w1 < 0.0f || w2 < 0.0f)
+                    continue;
+            }
+            else
+            {
+                if (w0 > 0.0f || w1 > 0.0f || w2 > 0.0f)
+                    continue;
+            }
+
+            w0 *= inv_area;
+            w1 *= inv_area;
+            w2 *= inv_area;
+
+            // Interpolate color
+            float color_r = c0.x * w0 + c1.x * w1 + c2.x * w2;
+            float color_g = c0.y * w0 + c1.y * w1 + c2.y * w2;
+            float color_b = c0.z * w0 + c1.z * w1 + c2.z * w2;
+            float color_a = c0.w * w0 + c1.w * w1 + c2.w * w2;
+
+            // Interpolate UV (only if using texture)
+            float tex_r = 1.0f, tex_g = 1.0f, tex_b = 1.0f, tex_a = 1.0f;
+
+            if (has_texture)
+            {
+                float u = uv0.x * w0 + uv1.x * w1 + uv2.x * w2;
+                float v = uv0.y * w0 + uv1.y * w1 + uv2.y * w2;
+
+                int tx = (int) (u * static_cast<float>(texture.Width));
+                int ty = (int) (v * static_cast<float>(texture.Height));
+                tx = std::clamp(tx, 0, texture.Width - 1);
+                ty = std::clamp(ty, 0, texture.Height - 1);
+
+                const size_t tex_index = static_cast<size_t>(ty) * static_cast<size_t>(texture.Pitch) + static_cast<size_t>(tx);
+                const Uint32 texel = texture.Pixels[tex_index];
+                tex_r = ((texel & texture.RMask) >> texture.RShift) * texture.RScale;
+                tex_g = ((texel & texture.GMask) >> texture.GShift) * texture.GScale;
+                tex_b = ((texel & texture.BMask) >> texture.BShift) * texture.BScale;
+                tex_a = ((texel & texture.AMask) >> texture.AShift) * texture.AScale;
+            }
+
+            float src_a = color_a * tex_a;
+            if (src_a <= 0.0f)
+                continue;
+
+            float src_r = color_r * tex_r;
+            float src_g = color_g * tex_g;
+            float src_b = color_b * tex_b;
+
+            // Track dirty region
+            if (!bd->HasDirtyRegion)
+            {
+                bd->MinDirtyX = bd->MaxDirtyX = x;
+                bd->MinDirtyY = bd->MaxDirtyY = y;
+                bd->HasDirtyRegion = true;
+            }
+            else
+            {
+                if (x < bd->MinDirtyX)
+                    bd->MinDirtyX = x;
+                if (x > bd->MaxDirtyX)
+                    bd->MaxDirtyX = x;
+                if (y < bd->MinDirtyY)
+                    bd->MinDirtyY = y;
+                if (y > bd->MaxDirtyY)
+                    bd->MaxDirtyY = y;
+            }
+
+            // Fast path for fully opaque pixels
+            if (src_a >= 1.0f)
+            {
+                int r = (int) (src_r * 255.0f + 0.5f);
+                int g = (int) (src_g * 255.0f + 0.5f);
+                int b = (int) (src_b * 255.0f + 0.5f);
+                r = (r > 255) ? 255 : r;
+                g = (g > 255) ? 255 : g;
+                b = (b > 255) ? 255 : b;
+
+                *pixel_ptr = (Uint32) r | ((Uint32) g << 8) | ((Uint32) b << 16) | 0xFF000000;
+            }
+            else
+            {
+                // Alpha blending with optimized integer math
+                Uint32 dst = *pixel_ptr;
+                int dst_r = (int) (dst & 0xFF);
+                int dst_g = (int) ((dst >> 8) & 0xFF);
+                int dst_b = (int) ((dst >> 16) & 0xFF);
+                int dst_a = (int) ((dst >> 24) & 0xFF);
+
+                int src_a_i = (int) (src_a * 255.0f + 0.5f);
+                int src_r_i = (int) (src_r * 255.0f + 0.5f);
+                int src_g_i = (int) (src_g * 255.0f + 0.5f);
+                int src_b_i = (int) (src_b * 255.0f + 0.5f);
+
+                src_r_i = (src_r_i > 255) ? 255 : src_r_i;
+                src_g_i = (src_g_i > 255) ? 255 : src_g_i;
+                src_b_i = (src_b_i > 255) ? 255 : src_b_i;
+                src_a_i = (src_a_i > 255) ? 255 : src_a_i;
+
+                int inv_a = 255 - src_a_i;
+
+                int out_r = (src_r_i * src_a_i + dst_r * inv_a + 128) >> 8;
+                int out_g = (src_g_i * src_a_i + dst_g * inv_a + 128) >> 8;
+                int out_b = (src_b_i * src_a_i + dst_b * inv_a + 128) >> 8;
+                int out_a = src_a_i + ((dst_a * inv_a + 128) >> 8);
+
+                out_r = (out_r > 255) ? 255 : out_r;
+                out_g = (out_g > 255) ? 255 : out_g;
+                out_b = (out_b > 255) ? 255 : out_b;
+                out_a = (out_a > 255) ? 255 : out_a;
+
+                *pixel_ptr = (Uint32) out_r | ((Uint32) out_g << 8) | ((Uint32) out_b << 16) | ((Uint32) out_a << 24);
+            }
+        }
+    }
+}
+
+bool ImGui_ImplSDLRenderer_Init(SDL_Renderer* renderer)
+{
+    ImGuiIO& io = ImGui::GetIO();
+    IM_ASSERT(io.BackendRendererUserData == nullptr && "Already initialized a renderer backend!");
+    IM_ASSERT(renderer != nullptr && "SDL_Renderer not initialized!");
+
+    ImGui_ImplSDLRenderer_Data* bd = IM_NEW(ImGui_ImplSDLRenderer_Data)();
+    io.BackendRendererUserData = (void*) bd;
+    io.BackendRendererName = "imgui_impl_sdlrenderer_legacy_optimized";
+    io.BackendFlags |= ImGuiBackendFlags_RendererHasVtxOffset;
+
+    bd->SDLRenderer = renderer;
+    bd->PerfFrequency = SDL_GetPerformanceFrequency();
+
+    const char* profile_env = SDL_getenv("IMGUI_LEGACY_PROFILE");
+    if (profile_env == nullptr || profile_env[0] == '\0')
+        profile_env = SDL_getenv("SDLREADER_PROFILE_LEGACY");
+    if (profile_env != nullptr && profile_env[0] != '0')
+    {
+        bd->EnableProfiling = true;
+        const char* freq_env = SDL_getenv("IMGUI_LEGACY_PROFILE_FREQ");
+        if (freq_env != nullptr)
+        {
+            int freq = atoi(freq_env);
+            if (freq > 0)
+                bd->ProfileLogFrequency = freq;
+        }
+
+        SDL_Log("ImGui legacy profiling enabled (freq=%d)", bd->ProfileLogFrequency);
+    }
+    else
+    {
+        SDL_Log("ImGui legacy profiling disabled. Set IMGUI_LEGACY_PROFILE=1 to enable logging.");
+    }
+
+    return true;
+}
+
+void ImGui_ImplSDLRenderer_Shutdown()
+{
+    ImGui_ImplSDLRenderer_Data* bd = ImGui_ImplSDLRenderer_GetBackendData();
+    if (bd == nullptr)
+        return;
+
+    ImGui_ImplSDLRenderer_DestroyDeviceObjects();
+
+    ImGuiIO& io = ImGui::GetIO();
+    io.BackendRendererName = nullptr;
+    io.BackendRendererUserData = nullptr;
+    IM_DELETE(bd);
+}
+
+void ImGui_ImplSDLRenderer_NewFrame()
+{
+    ImGui_ImplSDLRenderer_Data* bd = ImGui_ImplSDLRenderer_GetBackendData();
+    IM_ASSERT(bd != nullptr && "Did you call ImGui_ImplSDLRenderer_Init()?");
+
+    if (bd->FontTexture == nullptr)
+        ImGui_ImplSDLRenderer_CreateDeviceObjects();
+}
+
+void ImGui_ImplSDLRenderer_RenderDrawData(ImDrawData* draw_data)
+{
+    ImGui_ImplSDLRenderer_Data* bd = ImGui_ImplSDLRenderer_GetBackendData();
+    if (bd == nullptr)
+        return;
+
+    float renderer_scale_x = 1.0f;
+    float renderer_scale_y = 1.0f;
+    SDL_RenderGetScale(bd->SDLRenderer, &renderer_scale_x, &renderer_scale_y);
+
+    ImVec2 render_scale;
+    render_scale.x = (renderer_scale_x == 1.0f) ? draw_data->FramebufferScale.x : 1.0f;
+    render_scale.y = (renderer_scale_y == 1.0f) ? draw_data->FramebufferScale.y : 1.0f;
+
+    int fb_width = (int) (draw_data->DisplaySize.x * render_scale.x);
+    int fb_height = (int) (draw_data->DisplaySize.y * render_scale.y);
+    if (fb_width <= 0 || fb_height <= 0)
+        return;
+
+    bool framebuffer_resized = (bd->FrameTexture == nullptr) || bd->FrameWidth != fb_width || bd->FrameHeight != fb_height;
+    if (!ImGui_ImplSDLRenderer_EnsureFramebuffer(bd, fb_width, fb_height))
+        return;
+
+    Uint64 frame_hash = ImGui_ImplSDLRenderer_HashDrawData(draw_data);
+    bool geometry_changed = framebuffer_resized || !bd->CachedFrameValid || bd->LastFrameHash != frame_hash;
+    bool used_cached_frame = false;
+
+    struct BackupSDLRendererState
+    {
+        SDL_Rect Viewport;
+        bool ClipEnabled;
+        SDL_Rect ClipRect;
+    };
+
+    BackupSDLRendererState old = {};
+    old.ClipEnabled = SDL_RenderIsClipEnabled(bd->SDLRenderer) == SDL_TRUE;
+    SDL_RenderGetViewport(bd->SDLRenderer, &old.Viewport);
+    SDL_RenderGetClipRect(bd->SDLRenderer, &old.ClipRect);
+
+    ImVec2 clip_off = draw_data->DisplayPos;
+    ImVec2 clip_scale = render_scale;
+
+    ImGui_ImplSDLRenderer_SetupRenderState();
+
+    Uint64 frame_start = 0;
+    if (bd->EnableProfiling)
+        frame_start = SDL_GetPerformanceCounter();
+
+    if (geometry_changed)
+    {
+        for (int n = 0; n < draw_data->CmdListsCount; n++)
+        {
+            const ImDrawList* cmd_list = draw_data->CmdLists[n];
+            const ImDrawVert* vtx_buffer = cmd_list->VtxBuffer.Data;
+            const ImDrawIdx* idx_buffer = cmd_list->IdxBuffer.Data;
+
+            for (int cmd_i = 0; cmd_i < cmd_list->CmdBuffer.Size; cmd_i++)
+            {
+                const ImDrawCmd* pcmd = &cmd_list->CmdBuffer[cmd_i];
+                if (pcmd->UserCallback)
+                {
+                    if (pcmd->UserCallback == ImDrawCallback_ResetRenderState)
+                        ImGui_ImplSDLRenderer_SetupRenderState();
+                    else
+                        pcmd->UserCallback(cmd_list, pcmd);
+                    continue;
+                }
+
+                ImVec2 clip_min = ImVec2((pcmd->ClipRect.x - clip_off.x) * clip_scale.x,
+                                         (pcmd->ClipRect.y - clip_off.y) * clip_scale.y);
+                ImVec2 clip_max = ImVec2((pcmd->ClipRect.z - clip_off.x) * clip_scale.x,
+                                         (pcmd->ClipRect.w - clip_off.y) * clip_scale.y);
+
+                if (clip_max.x <= clip_min.x || clip_max.y <= clip_min.y)
+                    continue;
+
+                SDL_Rect clip_rect;
+                clip_rect.x = (int) std::floor(clip_min.x);
+                clip_rect.y = (int) std::floor(clip_min.y);
+                clip_rect.w = (int) std::ceil(clip_max.x - clip_min.x);
+                clip_rect.h = (int) std::ceil(clip_max.y - clip_min.y);
+
+                clip_rect.x = std::max(clip_rect.x, 0);
+                clip_rect.y = std::max(clip_rect.y, 0);
+                if (clip_rect.x + clip_rect.w > bd->FrameWidth)
+                    clip_rect.w = bd->FrameWidth - clip_rect.x;
+                if (clip_rect.y + clip_rect.h > bd->FrameHeight)
+                    clip_rect.h = bd->FrameHeight - clip_rect.y;
+
+                if (clip_rect.w <= 0 || clip_rect.h <= 0)
+                    continue;
+
+                SDL_RenderSetClipRect(bd->SDLRenderer, &clip_rect);
+
+                SDL_Texture* texture = (SDL_Texture*) pcmd->GetTexID();
+                const ImGui_ImplSDLRenderer_TextureSample tex_sample = ImGui_ImplSDLRenderer_GetTextureSample(bd, texture);
+
+                for (unsigned int idx = 0; idx < pcmd->ElemCount; idx += 3)
+                {
+                    const unsigned int index0 = pcmd->VtxOffset + (unsigned int) idx_buffer[pcmd->IdxOffset + idx + 0];
+                    const unsigned int index1 = pcmd->VtxOffset + (unsigned int) idx_buffer[pcmd->IdxOffset + idx + 1];
+                    const unsigned int index2 = pcmd->VtxOffset + (unsigned int) idx_buffer[pcmd->IdxOffset + idx + 2];
+
+                    const ImDrawVert& v0 = vtx_buffer[index0];
+                    const ImDrawVert& v1 = vtx_buffer[index1];
+                    const ImDrawVert& v2 = vtx_buffer[index2];
+
+                    ImVec2 p0 = ImVec2((v0.pos.x - clip_off.x) * clip_scale.x, (v0.pos.y - clip_off.y) * clip_scale.y);
+                    ImVec2 p1 = ImVec2((v1.pos.x - clip_off.x) * clip_scale.x, (v1.pos.y - clip_off.y) * clip_scale.y);
+                    ImVec2 p2 = ImVec2((v2.pos.x - clip_off.x) * clip_scale.x, (v2.pos.y - clip_off.y) * clip_scale.y);
+
+                    ImVec4 c0 = ImGui_ImplSDLRenderer_UnpackColor(v0.col);
+                    ImVec4 c1 = ImGui_ImplSDLRenderer_UnpackColor(v1.col);
+                    ImVec4 c2 = ImGui_ImplSDLRenderer_UnpackColor(v2.col);
+
+                    ImGui_ImplSDLRenderer_RasterizeTriangle(bd, p0, p1, p2, v0.uv, v1.uv, v2.uv, c0, c1, c2, tex_sample, clip_rect);
+                }
+            }
+        }
+    }
+    else
+    {
+        used_cached_frame = true;
+    }
+
+    bd->CachedFrameValid = true;
+    bd->LastFrameHash = frame_hash;
+
+    SDL_RenderSetViewport(bd->SDLRenderer, &old.Viewport);
+    SDL_RenderSetClipRect(bd->SDLRenderer, old.ClipEnabled ? &old.ClipRect : nullptr);
+
+    bool performed_update = false;
+    int dirty_pixels = 0;
+
+    if (bd->FrameTexture)
+    {
+        if (bd->HasDirtyRegion)
+        {
+            int min_x = std::max(0, bd->MinDirtyX);
+            int min_y = std::max(0, bd->MinDirtyY);
+            int max_x = std::min(bd->FrameWidth - 1, bd->MaxDirtyX);
+            int max_y = std::min(bd->FrameHeight - 1, bd->MaxDirtyY);
+
+            int dirty_w = max_x - min_x + 1;
+            int dirty_h = max_y - min_y + 1;
+
+            if (dirty_w > 0 && dirty_h > 0)
+            {
+                SDL_Rect dirty_rect = {min_x, min_y, dirty_w, dirty_h};
+                const Uint32* src = bd->Framebuffer.data() + (size_t) min_y * bd->FrameWidth + min_x;
+                if (SDL_UpdateTexture(bd->FrameTexture, &dirty_rect, src, bd->FrameWidth * (int) sizeof(Uint32)) == 0)
+                {
+                    performed_update = true;
+                    dirty_pixels = dirty_w * dirty_h;
+                }
+            }
+        }
+
+        bd->LastDirtyPixels = performed_update ? dirty_pixels : 0;
+        bd->LastFrameHadWork = performed_update;
+
+        SDL_RenderCopy(bd->SDLRenderer, bd->FrameTexture, nullptr, nullptr);
+    }
+
+    if (bd->EnableProfiling)
+    {
+        Uint64 elapsed = SDL_GetPerformanceCounter() - frame_start;
+        if (++bd->ProfileCounter >= bd->ProfileLogFrequency)
+        {
+            bd->ProfileCounter = 0;
+            double ms = (double) elapsed * 1000.0 / (double) (bd->PerfFrequency ? bd->PerfFrequency : 1);
+            const char* cache_state = used_cached_frame ? "hit" : "miss";
+            SDL_Log("ImGui legacy frame %.3f ms (fb=%dx%d dirty_pixels=%d updated=%s cache=%s)",
+                    ms,
+                    bd->FrameWidth,
+                    bd->FrameHeight,
+                    bd->LastDirtyPixels,
+                    performed_update ? "yes" : "no",
+                    cache_state);
+        }
+    }
+}
+
+bool ImGui_ImplSDLRenderer_CreateFontsTexture()
+{
+    ImGuiIO& io = ImGui::GetIO();
+    ImGui_ImplSDLRenderer_Data* bd = ImGui_ImplSDLRenderer_GetBackendData();
+    IM_ASSERT(bd != nullptr);
+
+    unsigned char* pixels = nullptr;
+    int width = 0, height = 0;
+    io.Fonts->GetTexDataAsRGBA32(&pixels, &width, &height);
+    if (width <= 0 || height <= 0 || pixels == nullptr)
+        return false;
+
+    bd->FontPixels.resize((size_t) width * (size_t) height);
+    memcpy(bd->FontPixels.data(), pixels, (size_t) width * (size_t) height * sizeof(ImU32));
+    bd->FontWidth = width;
+    bd->FontHeight = height;
+
+    if (bd->FontTexture)
+    {
+        SDL_DestroyTexture(bd->FontTexture);
+        bd->FontTexture = nullptr;
+    }
+
+    bd->FontTexture = SDL_CreateTexture(bd->SDLRenderer, SDL_PIXELFORMAT_ABGR8888, SDL_TEXTUREACCESS_STATIC, width, height);
+    if (bd->FontTexture == nullptr)
+    {
+        SDL_Log("Failed to create font texture: %s", SDL_GetError());
+        bd->FontPixels.clear();
+        bd->FontWidth = 0;
+        bd->FontHeight = 0;
+        return false;
+    }
+
+    SDL_UpdateTexture(bd->FontTexture, nullptr, pixels, width * 4);
+    SDL_SetTextureBlendMode(bd->FontTexture, SDL_BLENDMODE_BLEND);
+
+    io.Fonts->SetTexID((ImTextureID) (intptr_t) bd->FontTexture);
+    return true;
+}
+
+void ImGui_ImplSDLRenderer_DestroyFontsTexture()
+{
+    ImGuiIO& io = ImGui::GetIO();
+    ImGui_ImplSDLRenderer_Data* bd = ImGui_ImplSDLRenderer_GetBackendData();
+    if (bd == nullptr)
+        return;
+
+    if (bd->FontTexture)
+    {
+        SDL_DestroyTexture(bd->FontTexture);
+        bd->FontTexture = nullptr;
+    }
+
+    bd->FontPixels.clear();
+    bd->FontWidth = 0;
+    bd->FontHeight = 0;
+    io.Fonts->SetTexID(nullptr);
+}
+
+bool ImGui_ImplSDLRenderer_CreateDeviceObjects()
+{
+    return ImGui_ImplSDLRenderer_CreateFontsTexture();
+}
+
+void ImGui_ImplSDLRenderer_DestroyDeviceObjects()
+{
+    ImGui_ImplSDLRenderer_Data* bd = ImGui_ImplSDLRenderer_GetBackendData();
+    if (bd == nullptr)
+        return;
+
+    ImGui_ImplSDLRenderer_DestroyFontsTexture();
+
+    if (bd->FrameTexture)
+    {
+        SDL_DestroyTexture(bd->FrameTexture);
+        bd->FrameTexture = nullptr;
+    }
+
+    bd->Framebuffer.clear();
+    bd->FrameWidth = 0;
+    bd->FrameHeight = 0;
+    bd->HasDirtyRegion = false;
+    bd->TextureCache.clear();
+}
+
+#endif // SDL_VERSION_ATLEAST(2,0,17)
