diff --git a/backends/imgui_impl_sdlrenderer.cpp b/backends/imgui_impl_sdlrenderer.cpp
index 87381f2..48150da 100644
--- a/backends/imgui_impl_sdlrenderer.cpp
+++ b/backends/imgui_impl_sdlrenderer.cpp
@@ -24,33 +24,39 @@
 //  2021-10-06: Backup and restore modified ClipRect/Viewport.
 //  2021-09-21: Initial version.
 
-#include "imgui.h"
 #include "imgui_impl_sdlrenderer.h"
+#include "imgui.h"
 #if defined(_MSC_VER) && _MSC_VER <= 1500 // MSVC 2008 or earlier
-#include <stddef.h>     // intptr_t
+#include <stddef.h>                       // intptr_t
 #else
-#include <stdint.h>     // intptr_t
+#include <stdint.h> // intptr_t
 #endif
 
+#include <algorithm>
+#include <cmath>
+#include <cstring>
+#include <vector>
+
 // SDL
 #include <SDL.h>
-#if !SDL_VERSION_ATLEAST(2,0,17)
-#error This backend requires SDL 2.0.17+ because of SDL_RenderGeometry() function
-#endif
+#if SDL_VERSION_ATLEAST(2, 0, 17)
 
 // SDL_Renderer data
 struct ImGui_ImplSDLRenderer_Data
 {
-    SDL_Renderer*   SDLRenderer;
-    SDL_Texture*    FontTexture;
-    ImGui_ImplSDLRenderer_Data() { memset((void*)this, 0, sizeof(*this)); }
+    SDL_Renderer* SDLRenderer;
+    SDL_Texture* FontTexture;
+    ImGui_ImplSDLRenderer_Data()
+    {
+        memset((void*) this, 0, sizeof(*this));
+    }
 };
 
 // Backend data stored in io.BackendRendererUserData to allow support for multiple Dear ImGui contexts
 // It is STRONGLY preferred that you use docking branch with multi-viewports (== single Dear ImGui context + multiple windows) instead of multiple Dear ImGui contexts.
 static ImGui_ImplSDLRenderer_Data* ImGui_ImplSDLRenderer_GetBackendData()
 {
-    return ImGui::GetCurrentContext() ? (ImGui_ImplSDLRenderer_Data*)ImGui::GetIO().BackendRendererUserData : nullptr;
+    return ImGui::GetCurrentContext() ? (ImGui_ImplSDLRenderer_Data*) ImGui::GetIO().BackendRendererUserData : nullptr;
 }
 
 // Functions
@@ -62,9 +68,9 @@ bool ImGui_ImplSDLRenderer_Init(SDL_Renderer* renderer)
 
     // Setup backend capabilities flags
     ImGui_ImplSDLRenderer_Data* bd = IM_NEW(ImGui_ImplSDLRenderer_Data)();
-    io.BackendRendererUserData = (void*)bd;
+    io.BackendRendererUserData = (void*) bd;
     io.BackendRendererName = "imgui_impl_sdlrenderer";
-    io.BackendFlags |= ImGuiBackendFlags_RendererHasVtxOffset;  // We can honor the ImDrawCmd::VtxOffset field, allowing for large meshes.
+    io.BackendFlags |= ImGuiBackendFlags_RendererHasVtxOffset; // We can honor the ImDrawCmd::VtxOffset field, allowing for large meshes.
 
     bd->SDLRenderer = renderer;
 
@@ -86,12 +92,12 @@ void ImGui_ImplSDLRenderer_Shutdown()
 
 static void ImGui_ImplSDLRenderer_SetupRenderState()
 {
-	ImGui_ImplSDLRenderer_Data* bd = ImGui_ImplSDLRenderer_GetBackendData();
+    ImGui_ImplSDLRenderer_Data* bd = ImGui_ImplSDLRenderer_GetBackendData();
 
-	// Clear out any viewports and cliprect set by the user
+    // Clear out any viewports and cliprect set by the user
     // FIXME: Technically speaking there are lots of other things we could backup/setup/restore during our render process.
-	SDL_RenderSetViewport(bd->SDLRenderer, nullptr);
-	SDL_RenderSetClipRect(bd->SDLRenderer, nullptr);
+    SDL_RenderSetViewport(bd->SDLRenderer, nullptr);
+    SDL_RenderSetClipRect(bd->SDLRenderer, nullptr);
 }
 
 void ImGui_ImplSDLRenderer_NewFrame()
@@ -105,39 +111,39 @@ void ImGui_ImplSDLRenderer_NewFrame()
 
 void ImGui_ImplSDLRenderer_RenderDrawData(ImDrawData* draw_data)
 {
-	ImGui_ImplSDLRenderer_Data* bd = ImGui_ImplSDLRenderer_GetBackendData();
+    ImGui_ImplSDLRenderer_Data* bd = ImGui_ImplSDLRenderer_GetBackendData();
 
-	// If there's a scale factor set by the user, use that instead
+    // If there's a scale factor set by the user, use that instead
     // If the user has specified a scale factor to SDL_Renderer already via SDL_RenderSetScale(), SDL will scale whatever we pass
     // to SDL_RenderGeometryRaw() by that scale factor. In that case we don't want to be also scaling it ourselves here.
     float rsx = 1.0f;
-	float rsy = 1.0f;
-	SDL_RenderGetScale(bd->SDLRenderer, &rsx, &rsy);
+    float rsy = 1.0f;
+    SDL_RenderGetScale(bd->SDLRenderer, &rsx, &rsy);
     ImVec2 render_scale;
-	render_scale.x = (rsx == 1.0f) ? draw_data->FramebufferScale.x : 1.0f;
-	render_scale.y = (rsy == 1.0f) ? draw_data->FramebufferScale.y : 1.0f;
+    render_scale.x = (rsx == 1.0f) ? draw_data->FramebufferScale.x : 1.0f;
+    render_scale.y = (rsy == 1.0f) ? draw_data->FramebufferScale.y : 1.0f;
 
-	// Avoid rendering when minimized, scale coordinates for retina displays (screen coordinates != framebuffer coordinates)
-	int fb_width = (int)(draw_data->DisplaySize.x * render_scale.x);
-	int fb_height = (int)(draw_data->DisplaySize.y * render_scale.y);
-	if (fb_width == 0 || fb_height == 0)
-		return;
+    // Avoid rendering when minimized, scale coordinates for retina displays (screen coordinates != framebuffer coordinates)
+    int fb_width = (int) (draw_data->DisplaySize.x * render_scale.x);
+    int fb_height = (int) (draw_data->DisplaySize.y * render_scale.y);
+    if (fb_width == 0 || fb_height == 0)
+        return;
 
     // Backup SDL_Renderer state that will be modified to restore it afterwards
     struct BackupSDLRendererState
     {
-        SDL_Rect    Viewport;
-        bool        ClipEnabled;
-        SDL_Rect    ClipRect;
+        SDL_Rect Viewport;
+        bool ClipEnabled;
+        SDL_Rect ClipRect;
     };
     BackupSDLRendererState old = {};
     old.ClipEnabled = SDL_RenderIsClipEnabled(bd->SDLRenderer) == SDL_TRUE;
     SDL_RenderGetViewport(bd->SDLRenderer, &old.Viewport);
     SDL_RenderGetClipRect(bd->SDLRenderer, &old.ClipRect);
 
-	// Will project scissor/clipping rectangles into framebuffer space
-	ImVec2 clip_off = draw_data->DisplayPos;         // (0,0) unless using multi-viewports
-	ImVec2 clip_scale = render_scale;
+    // Will project scissor/clipping rectangles into framebuffer space
+    ImVec2 clip_off = draw_data->DisplayPos; // (0,0) unless using multi-viewports
+    ImVec2 clip_scale = render_scale;
 
     // Render command lists
     ImGui_ImplSDLRenderer_SetupRenderState();
@@ -164,32 +170,44 @@ void ImGui_ImplSDLRenderer_RenderDrawData(ImDrawData* draw_data)
                 // Project scissor/clipping rectangles into framebuffer space
                 ImVec2 clip_min((pcmd->ClipRect.x - clip_off.x) * clip_scale.x, (pcmd->ClipRect.y - clip_off.y) * clip_scale.y);
                 ImVec2 clip_max((pcmd->ClipRect.z - clip_off.x) * clip_scale.x, (pcmd->ClipRect.w - clip_off.y) * clip_scale.y);
-                if (clip_min.x < 0.0f) { clip_min.x = 0.0f; }
-                if (clip_min.y < 0.0f) { clip_min.y = 0.0f; }
-                if (clip_max.x > (float)fb_width) { clip_max.x = (float)fb_width; }
-                if (clip_max.y > (float)fb_height) { clip_max.y = (float)fb_height; }
+                if (clip_min.x < 0.0f)
+                {
+                    clip_min.x = 0.0f;
+                }
+                if (clip_min.y < 0.0f)
+                {
+                    clip_min.y = 0.0f;
+                }
+                if (clip_max.x > (float) fb_width)
+                {
+                    clip_max.x = (float) fb_width;
+                }
+                if (clip_max.y > (float) fb_height)
+                {
+                    clip_max.y = (float) fb_height;
+                }
                 if (clip_max.x <= clip_min.x || clip_max.y <= clip_min.y)
                     continue;
 
-                SDL_Rect r = { (int)(clip_min.x), (int)(clip_min.y), (int)(clip_max.x - clip_min.x), (int)(clip_max.y - clip_min.y) };
+                SDL_Rect r = {(int) (clip_min.x), (int) (clip_min.y), (int) (clip_max.x - clip_min.x), (int) (clip_max.y - clip_min.y)};
                 SDL_RenderSetClipRect(bd->SDLRenderer, &r);
 
-                const float* xy = (const float*)(const void*)((const char*)(vtx_buffer + pcmd->VtxOffset) + IM_OFFSETOF(ImDrawVert, pos));
-                const float* uv = (const float*)(const void*)((const char*)(vtx_buffer + pcmd->VtxOffset) + IM_OFFSETOF(ImDrawVert, uv));
-#if SDL_VERSION_ATLEAST(2,0,19)
-                const SDL_Color* color = (const SDL_Color*)(const void*)((const char*)(vtx_buffer + pcmd->VtxOffset) + IM_OFFSETOF(ImDrawVert, col)); // SDL 2.0.19+
-#else
-                const int* color = (const int*)(const void*)((const char*)(vtx_buffer + pcmd->VtxOffset) + IM_OFFSETOF(ImDrawVert, col)); // SDL 2.0.17 and 2.0.18
-#endif
+                const float* xy = (const float*) (const void*) ((const char*) (vtx_buffer + pcmd->VtxOffset) + IM_OFFSETOF(ImDrawVert, pos));
+                const float* uv = (const float*) (const void*) ((const char*) (vtx_buffer + pcmd->VtxOffset) + IM_OFFSETOF(ImDrawVert, uv));
+                #if SDL_VERSION_ATLEAST(2, 0, 19)
+                const SDL_Color* color = (const SDL_Color*) (const void*) ((const char*) (vtx_buffer + pcmd->VtxOffset) + IM_OFFSETOF(ImDrawVert, col)); // SDL 2.0.19+
+                #else
+                const int* color = (const int*) (const void*) ((const char*) (vtx_buffer + pcmd->VtxOffset) + IM_OFFSETOF(ImDrawVert, col)); // SDL 2.0.17 and 2.0.18
+                #endif
 
                 // Bind texture, Draw
-				SDL_Texture* tex = (SDL_Texture*)pcmd->GetTexID();
+                SDL_Texture* tex = (SDL_Texture*) pcmd->GetTexID();
                 SDL_RenderGeometryRaw(bd->SDLRenderer, tex,
-                    xy, (int)sizeof(ImDrawVert),
-                    color, (int)sizeof(ImDrawVert),
-                    uv, (int)sizeof(ImDrawVert),
-                    cmd_list->VtxBuffer.Size - pcmd->VtxOffset,
-                    idx_buffer + pcmd->IdxOffset, pcmd->ElemCount, sizeof(ImDrawIdx));
+                                      xy, (int) sizeof(ImDrawVert),
+                                      color, (int) sizeof(ImDrawVert),
+                                      uv, (int) sizeof(ImDrawVert),
+                                      cmd_list->VtxBuffer.Size - pcmd->VtxOffset,
+                                      idx_buffer + pcmd->IdxOffset, pcmd->ElemCount, sizeof(ImDrawIdx));
             }
         }
     }
@@ -208,7 +226,7 @@ bool ImGui_ImplSDLRenderer_CreateFontsTexture()
     // Build texture atlas
     unsigned char* pixels;
     int width, height;
-    io.Fonts->GetTexDataAsRGBA32(&pixels, &width, &height);   // Load as RGBA 32-bit (75% of the memory is wasted, but default font is so small) because it is more likely to be compatible with user's existing shaders. If your ImTextureId represent a higher-level concept than just a GL texture id, consider calling GetTexDataAsAlpha8() instead to save on GPU memory.
+    io.Fonts->GetTexDataAsRGBA32(&pixels, &width, &height); // Load as RGBA 32-bit (75% of the memory is wasted, but default font is so small) because it is more likely to be compatible with user's existing shaders. If your ImTextureId represent a higher-level concept than just a GL texture id, consider calling GetTexDataAsAlpha8() instead to save on GPU memory.
 
     // Upload texture to graphics system
     // (Bilinear sampling is required by default. Set 'io.Fonts->Flags |= ImFontAtlasFlags_NoBakedLines' or 'style.AntiAliasedLinesUseTex = false' to allow point/nearest sampling)
@@ -223,7 +241,7 @@ bool ImGui_ImplSDLRenderer_CreateFontsTexture()
     SDL_SetTextureScaleMode(bd->FontTexture, SDL_ScaleModeLinear);
 
     // Store our identifier
-    io.Fonts->SetTexID((ImTextureID)(intptr_t)bd->FontTexture);
+    io.Fonts->SetTexID((ImTextureID) (intptr_t) bd->FontTexture);
 
     return true;
 }
@@ -249,3 +267,543 @@ void ImGui_ImplSDLRenderer_DestroyDeviceObjects()
 {
     ImGui_ImplSDLRenderer_DestroyFontsTexture();
 }
+#else
+
+struct ImGui_ImplSDLRenderer_Data
+{
+    SDL_Renderer* SDLRenderer;
+    SDL_Texture* FontTexture;
+    SDL_Texture* FrameTexture;
+    std::vector<ImU32> FontPixels;
+    int FontWidth;
+    int FontHeight;
+    std::vector<Uint32> Framebuffer;
+    int FrameWidth;
+    int FrameHeight;
+    int MinDirtyX, MinDirtyY, MaxDirtyX, MaxDirtyY;
+    bool HasDirtyRegion;
+
+    ImGui_ImplSDLRenderer_Data()
+    : SDLRenderer(nullptr), FontTexture(nullptr), FrameTexture(nullptr), FontWidth(0), FontHeight(0), FrameWidth(0), FrameHeight(0), MinDirtyX(0), MinDirtyY(0), MaxDirtyX(0), MaxDirtyY(0), HasDirtyRegion(false)
+    {
+    }
+};
+
+static ImGui_ImplSDLRenderer_Data* ImGui_ImplSDLRenderer_GetBackendData()
+{
+    return ImGui::GetCurrentContext() ? (ImGui_ImplSDLRenderer_Data*) ImGui::GetIO().BackendRendererUserData : nullptr;
+}
+
+static void ImGui_ImplSDLRenderer_SetupRenderState()
+{
+    ImGui_ImplSDLRenderer_Data* bd = ImGui_ImplSDLRenderer_GetBackendData();
+    SDL_RenderSetViewport(bd->SDLRenderer, nullptr);
+    SDL_RenderSetClipRect(bd->SDLRenderer, nullptr);
+}
+
+static bool ImGui_ImplSDLRenderer_EnsureFramebuffer(ImGui_ImplSDLRenderer_Data* bd, int width, int height)
+{
+    if (width <= 0 || height <= 0)
+        return false;
+
+    if (bd->FrameWidth != width || bd->FrameHeight != height || bd->FrameTexture == nullptr)
+    {
+        if (bd->FrameTexture)
+        {
+            SDL_DestroyTexture(bd->FrameTexture);
+            bd->FrameTexture = nullptr;
+        }
+
+        bd->Framebuffer.resize((size_t) width * (size_t) height);
+        bd->FrameWidth = width;
+        bd->FrameHeight = height;
+
+        bd->FrameTexture = SDL_CreateTexture(bd->SDLRenderer, SDL_PIXELFORMAT_ABGR8888, SDL_TEXTUREACCESS_STREAMING, width, height);
+        if (bd->FrameTexture == nullptr)
+        {
+            SDL_Log("Failed to create ImGui legacy framebuffer: %s", SDL_GetError());
+            bd->Framebuffer.clear();
+            bd->FrameWidth = 0;
+            bd->FrameHeight = 0;
+            return false;
+        }
+
+        SDL_SetTextureBlendMode(bd->FrameTexture, SDL_BLENDMODE_BLEND);
+        // Clear entire buffer on resize
+        std::fill(bd->Framebuffer.begin(), bd->Framebuffer.end(), 0u);
+    }
+    else if (bd->HasDirtyRegion)
+    {
+        // Only clear the dirty region from previous frame
+        int dirty_w = bd->MaxDirtyX - bd->MinDirtyX + 1;
+        int dirty_h = bd->MaxDirtyY - bd->MinDirtyY + 1;
+
+        if (dirty_w > 0 && dirty_h > 0)
+        {
+            for (int y = bd->MinDirtyY; y <= bd->MaxDirtyY && y < bd->FrameHeight; ++y)
+            {
+                size_t start_idx = (size_t) y * bd->FrameWidth + bd->MinDirtyX;
+                size_t count = std::min(dirty_w, bd->FrameWidth - bd->MinDirtyX);
+                std::fill(bd->Framebuffer.begin() + start_idx, bd->Framebuffer.begin() + start_idx + count, 0u);
+            }
+        }
+    }
+
+    // Reset dirty region tracking
+    bd->HasDirtyRegion = false;
+    bd->MinDirtyX = bd->FrameWidth;
+    bd->MinDirtyY = bd->FrameHeight;
+    bd->MaxDirtyX = -1;
+    bd->MaxDirtyY = -1;
+
+    return true;
+}
+
+static ImVec4 ImGui_ImplSDLRenderer_UnpackColor(ImU32 col)
+{
+    const float inv255 = 1.0f / 255.0f;
+    return ImVec4(
+        ((col >> IM_COL32_R_SHIFT) & 0xFF) * inv255,
+                  ((col >> IM_COL32_G_SHIFT) & 0xFF) * inv255,
+                  ((col >> IM_COL32_B_SHIFT) & 0xFF) * inv255,
+                  ((col >> IM_COL32_A_SHIFT) & 0xFF) * inv255);
+}
+
+static void ImGui_ImplSDLRenderer_RasterizeTriangle(
+    ImGui_ImplSDLRenderer_Data* bd,
+    const ImVec2& p0, const ImVec2& p1, const ImVec2& p2,
+    const ImVec2& uv0, const ImVec2& uv1, const ImVec2& uv2,
+    const ImVec4& c0, const ImVec4& c1, const ImVec4& c2,
+    SDL_Texture* texture, const SDL_Rect& clip_rect)
+{
+    float min_x = std::floor(std::min({p0.x, p1.x, p2.x}));
+    float max_x = std::ceil(std::max({p0.x, p1.x, p2.x}));
+    float min_y = std::floor(std::min({p0.y, p1.y, p2.y}));
+    float max_y = std::ceil(std::max({p0.y, p1.y, p2.y}));
+
+    int x0 = std::max((int) min_x, clip_rect.x);
+    int x1 = std::min((int) max_x, clip_rect.x + clip_rect.w - 1);
+    int y0 = std::max((int) min_y, clip_rect.y);
+    int y1 = std::min((int) max_y, clip_rect.y + clip_rect.h - 1);
+
+    if (x0 > x1 || y0 > y1)
+        return;
+
+    float area = (p1.y - p2.y) * (p0.x - p2.x) + (p2.x - p1.x) * (p0.y - p2.y);
+    if (fabsf(area) < 1e-6f)
+        return;
+    float inv_area = 1.0f / area;
+    bool area_positive = area > 0.0f;
+
+    // Precompute edge equation coefficients
+    float edge0_a = p1.y - p2.y;
+    float edge0_b = p2.x - p1.x;
+    float edge0_c = p1.x * p2.y - p2.x * p1.y;
+
+    float edge1_a = p2.y - p0.y;
+    float edge1_b = p0.x - p2.x;
+    float edge1_c = p2.x * p0.y - p0.x * p2.y;
+
+    // Cache font texture info for faster access
+    const bool is_font_texture = (texture == bd->FontTexture && !bd->FontPixels.empty() && bd->FontWidth > 0 && bd->FontHeight > 0);
+    const ImU32* font_data = is_font_texture ? bd->FontPixels.data() : nullptr;
+    const int font_w = bd->FontWidth;
+    const int font_h = bd->FontHeight;
+
+    // Scanline rasterization with incremental barycentric coordinates
+    for (int y = y0; y <= y1; ++y)
+    {
+        float py = y + 0.5f;
+
+        // Calculate barycentric coordinates at start of scanline
+        float px_start = x0 + 0.5f;
+        float w0_row = edge0_a * px_start + edge0_b * py + edge0_c;
+        float w1_row = edge1_a * px_start + edge1_b * py + edge1_c;
+
+        for (int x = x0; x <= x1; ++x)
+        {
+            float w0 = w0_row;
+            float w1 = w1_row;
+            float w2 = area - w0 - w1;
+
+            // Inside test
+            if (area_positive)
+            {
+                if (w0 < 0.0f || w1 < 0.0f || w2 < 0.0f)
+                {
+                    w0_row += edge0_a;
+                    w1_row += edge1_a;
+                    continue;
+                }
+            }
+            else
+            {
+                if (w0 > 0.0f || w1 > 0.0f || w2 > 0.0f)
+                {
+                    w0_row += edge0_a;
+                    w1_row += edge1_a;
+                    continue;
+                }
+            }
+
+            w0 *= inv_area;
+            w1 *= inv_area;
+            w2 *= inv_area;
+
+            // Interpolate color
+            float color_r = c0.x * w0 + c1.x * w1 + c2.x * w2;
+            float color_g = c0.y * w0 + c1.y * w1 + c2.y * w2;
+            float color_b = c0.z * w0 + c1.z * w1 + c2.z * w2;
+            float color_a = c0.w * w0 + c1.w * w1 + c2.w * w2;
+
+            // Interpolate UV (only if using texture)
+            float tex_r = 1.0f, tex_g = 1.0f, tex_b = 1.0f, tex_a = 1.0f;
+
+            if (is_font_texture)
+            {
+                float u = uv0.x * w0 + uv1.x * w1 + uv2.x * w2;
+                float v = uv0.y * w0 + uv1.y * w1 + uv2.y * w2;
+
+                int tx = (int) (u * font_w);
+                int ty = (int) (v * font_h);
+                tx = std::clamp(tx, 0, font_w - 1);
+                ty = std::clamp(ty, 0, font_h - 1);
+
+                const ImU32 texel = font_data[ty * font_w + tx];
+                const float inv255 = 1.0f / 255.0f;
+                tex_r = ((texel >> IM_COL32_R_SHIFT) & 0xFF) * inv255;
+                tex_g = ((texel >> IM_COL32_G_SHIFT) & 0xFF) * inv255;
+                tex_b = ((texel >> IM_COL32_B_SHIFT) & 0xFF) * inv255;
+                tex_a = ((texel >> IM_COL32_A_SHIFT) & 0xFF) * inv255;
+            }
+
+            float src_a = color_a * tex_a;
+            if (src_a <= 0.0f)
+            {
+                w0_row += edge0_a;
+                w1_row += edge1_a;
+                continue;
+            }
+
+            float src_r = color_r * tex_r;
+            float src_g = color_g * tex_g;
+            float src_b = color_b * tex_b;
+
+            // Inline blending for better performance
+            const size_t index = (size_t) y * bd->FrameWidth + x;
+
+            // Track dirty region
+            if (!bd->HasDirtyRegion)
+            {
+                bd->MinDirtyX = bd->MaxDirtyX = x;
+                bd->MinDirtyY = bd->MaxDirtyY = y;
+                bd->HasDirtyRegion = true;
+            }
+            else
+            {
+                if (x < bd->MinDirtyX)
+                    bd->MinDirtyX = x;
+                if (x > bd->MaxDirtyX)
+                    bd->MaxDirtyX = x;
+                if (y < bd->MinDirtyY)
+                    bd->MinDirtyY = y;
+                if (y > bd->MaxDirtyY)
+                    bd->MaxDirtyY = y;
+            }
+
+            // Fast path for fully opaque pixels
+            if (src_a >= 1.0f)
+            {
+                int r = (int) (src_r * 255.0f + 0.5f);
+                int g = (int) (src_g * 255.0f + 0.5f);
+                int b = (int) (src_b * 255.0f + 0.5f);
+                r = (r > 255) ? 255 : r;
+                g = (g > 255) ? 255 : g;
+                b = (b > 255) ? 255 : b;
+
+                bd->Framebuffer[index] = (Uint32) r | ((Uint32) g << 8) | ((Uint32) b << 16) | 0xFF000000;
+            }
+            else
+            {
+                // Alpha blending with optimized integer math
+                Uint32 dst = bd->Framebuffer[index];
+                int dst_r = (int) (dst & 0xFF);
+                int dst_g = (int) ((dst >> 8) & 0xFF);
+                int dst_b = (int) ((dst >> 16) & 0xFF);
+                int dst_a = (int) ((dst >> 24) & 0xFF);
+
+                int src_a_i = (int) (src_a * 255.0f + 0.5f);
+                int src_r_i = (int) (src_r * 255.0f + 0.5f);
+                int src_g_i = (int) (src_g * 255.0f + 0.5f);
+                int src_b_i = (int) (src_b * 255.0f + 0.5f);
+
+                src_r_i = (src_r_i > 255) ? 255 : src_r_i;
+                src_g_i = (src_g_i > 255) ? 255 : src_g_i;
+                src_b_i = (src_b_i > 255) ? 255 : src_b_i;
+                src_a_i = (src_a_i > 255) ? 255 : src_a_i;
+
+                int inv_a = 255 - src_a_i;
+
+                int out_r = (src_r_i * src_a_i + dst_r * inv_a + 128) >> 8;
+                int out_g = (src_g_i * src_a_i + dst_g * inv_a + 128) >> 8;
+                int out_b = (src_b_i * src_a_i + dst_b * inv_a + 128) >> 8;
+                int out_a = src_a_i + ((dst_a * inv_a + 128) >> 8);
+
+                out_r = (out_r > 255) ? 255 : out_r;
+                out_g = (out_g > 255) ? 255 : out_g;
+                out_b = (out_b > 255) ? 255 : out_b;
+                out_a = (out_a > 255) ? 255 : out_a;
+
+                bd->Framebuffer[index] = (Uint32) out_r | ((Uint32) out_g << 8) | ((Uint32) out_b << 16) | ((Uint32) out_a << 24);
+            }
+
+            // Increment barycentric coordinates for next pixel
+            w0_row += edge0_a;
+            w1_row += edge1_a;
+        }
+    }
+}
+
+bool ImGui_ImplSDLRenderer_Init(SDL_Renderer* renderer)
+{
+    ImGuiIO& io = ImGui::GetIO();
+    IM_ASSERT(io.BackendRendererUserData == nullptr && "Already initialized a renderer backend!");
+    IM_ASSERT(renderer != nullptr && "SDL_Renderer not initialized!");
+
+    ImGui_ImplSDLRenderer_Data* bd = IM_NEW(ImGui_ImplSDLRenderer_Data)();
+    io.BackendRendererUserData = (void*) bd;
+    io.BackendRendererName = "imgui_impl_sdlrenderer_legacy_optimized";
+    io.BackendFlags |= ImGuiBackendFlags_RendererHasVtxOffset;
+
+    bd->SDLRenderer = renderer;
+
+    return true;
+}
+
+void ImGui_ImplSDLRenderer_Shutdown()
+{
+    ImGui_ImplSDLRenderer_Data* bd = ImGui_ImplSDLRenderer_GetBackendData();
+    if (bd == nullptr)
+        return;
+
+    ImGui_ImplSDLRenderer_DestroyDeviceObjects();
+
+    ImGuiIO& io = ImGui::GetIO();
+    io.BackendRendererName = nullptr;
+    io.BackendRendererUserData = nullptr;
+    IM_DELETE(bd);
+}
+
+void ImGui_ImplSDLRenderer_NewFrame()
+{
+    ImGui_ImplSDLRenderer_Data* bd = ImGui_ImplSDLRenderer_GetBackendData();
+    IM_ASSERT(bd != nullptr && "Did you call ImGui_ImplSDLRenderer_Init()?");
+
+    if (bd->FontTexture == nullptr)
+        ImGui_ImplSDLRenderer_CreateDeviceObjects();
+}
+
+void ImGui_ImplSDLRenderer_RenderDrawData(ImDrawData* draw_data)
+{
+    ImGui_ImplSDLRenderer_Data* bd = ImGui_ImplSDLRenderer_GetBackendData();
+    if (bd == nullptr)
+        return;
+
+    float renderer_scale_x = 1.0f;
+    float renderer_scale_y = 1.0f;
+    SDL_RenderGetScale(bd->SDLRenderer, &renderer_scale_x, &renderer_scale_y);
+
+    ImVec2 render_scale;
+    render_scale.x = (renderer_scale_x == 1.0f) ? draw_data->FramebufferScale.x : 1.0f;
+    render_scale.y = (renderer_scale_y == 1.0f) ? draw_data->FramebufferScale.y : 1.0f;
+
+    int fb_width = (int) (draw_data->DisplaySize.x * render_scale.x);
+    int fb_height = (int) (draw_data->DisplaySize.y * render_scale.y);
+    if (fb_width <= 0 || fb_height <= 0)
+        return;
+
+    if (!ImGui_ImplSDLRenderer_EnsureFramebuffer(bd, fb_width, fb_height))
+        return;
+
+    struct BackupSDLRendererState
+    {
+        SDL_Rect Viewport;
+        bool ClipEnabled;
+        SDL_Rect ClipRect;
+    };
+
+    BackupSDLRendererState old = {};
+    old.ClipEnabled = SDL_RenderIsClipEnabled(bd->SDLRenderer) == SDL_TRUE;
+    SDL_RenderGetViewport(bd->SDLRenderer, &old.Viewport);
+    SDL_RenderGetClipRect(bd->SDLRenderer, &old.ClipRect);
+
+    ImVec2 clip_off = draw_data->DisplayPos;
+    ImVec2 clip_scale = render_scale;
+
+    ImGui_ImplSDLRenderer_SetupRenderState();
+
+    for (int n = 0; n < draw_data->CmdListsCount; n++)
+    {
+        const ImDrawList* cmd_list = draw_data->CmdLists[n];
+        const ImDrawVert* vtx_buffer = cmd_list->VtxBuffer.Data;
+        const ImDrawIdx* idx_buffer = cmd_list->IdxBuffer.Data;
+
+        for (int cmd_i = 0; cmd_i < cmd_list->CmdBuffer.Size; cmd_i++)
+        {
+            const ImDrawCmd* pcmd = &cmd_list->CmdBuffer[cmd_i];
+            if (pcmd->UserCallback)
+            {
+                if (pcmd->UserCallback == ImDrawCallback_ResetRenderState)
+                    ImGui_ImplSDLRenderer_SetupRenderState();
+                else
+                    pcmd->UserCallback(cmd_list, pcmd);
+                continue;
+            }
+
+            ImVec2 clip_min = ImVec2((pcmd->ClipRect.x - clip_off.x) * clip_scale.x,
+                                     (pcmd->ClipRect.y - clip_off.y) * clip_scale.y);
+            ImVec2 clip_max = ImVec2((pcmd->ClipRect.z - clip_off.x) * clip_scale.x,
+                                     (pcmd->ClipRect.w - clip_off.y) * clip_scale.y);
+
+            if (clip_max.x <= clip_min.x || clip_max.y <= clip_min.y)
+                continue;
+
+            SDL_Rect clip_rect;
+            clip_rect.x = (int) std::floor(clip_min.x);
+            clip_rect.y = (int) std::floor(clip_min.y);
+            clip_rect.w = (int) std::ceil(clip_max.x - clip_min.x);
+            clip_rect.h = (int) std::ceil(clip_max.y - clip_min.y);
+
+            clip_rect.x = std::max(clip_rect.x, 0);
+            clip_rect.y = std::max(clip_rect.y, 0);
+            if (clip_rect.x + clip_rect.w > bd->FrameWidth)
+                clip_rect.w = bd->FrameWidth - clip_rect.x;
+            if (clip_rect.y + clip_rect.h > bd->FrameHeight)
+                clip_rect.h = bd->FrameHeight - clip_rect.y;
+
+            if (clip_rect.w <= 0 || clip_rect.h <= 0)
+                continue;
+
+            SDL_RenderSetClipRect(bd->SDLRenderer, &clip_rect);
+
+            SDL_Texture* texture = (SDL_Texture*) pcmd->GetTexID();
+
+            for (unsigned int idx = 0; idx < pcmd->ElemCount; idx += 3)
+            {
+                const unsigned int index0 = pcmd->VtxOffset + (unsigned int) idx_buffer[pcmd->IdxOffset + idx + 0];
+                const unsigned int index1 = pcmd->VtxOffset + (unsigned int) idx_buffer[pcmd->IdxOffset + idx + 1];
+                const unsigned int index2 = pcmd->VtxOffset + (unsigned int) idx_buffer[pcmd->IdxOffset + idx + 2];
+
+                const ImDrawVert& v0 = vtx_buffer[index0];
+                const ImDrawVert& v1 = vtx_buffer[index1];
+                const ImDrawVert& v2 = vtx_buffer[index2];
+
+                ImVec2 p0 = ImVec2((v0.pos.x - clip_off.x) * clip_scale.x, (v0.pos.y - clip_off.y) * clip_scale.y);
+                ImVec2 p1 = ImVec2((v1.pos.x - clip_off.x) * clip_scale.x, (v1.pos.y - clip_off.y) * clip_scale.y);
+                ImVec2 p2 = ImVec2((v2.pos.x - clip_off.x) * clip_scale.x, (v2.pos.y - clip_off.y) * clip_scale.y);
+
+                ImVec4 c0 = ImGui_ImplSDLRenderer_UnpackColor(v0.col);
+                ImVec4 c1 = ImGui_ImplSDLRenderer_UnpackColor(v1.col);
+                ImVec4 c2 = ImGui_ImplSDLRenderer_UnpackColor(v2.col);
+
+                ImGui_ImplSDLRenderer_RasterizeTriangle(bd, p0, p1, p2, v0.uv, v1.uv, v2.uv, c0, c1, c2, texture, clip_rect);
+            }
+        }
+    }
+
+    SDL_RenderSetViewport(bd->SDLRenderer, &old.Viewport);
+    SDL_RenderSetClipRect(bd->SDLRenderer, old.ClipEnabled ? &old.ClipRect : nullptr);
+
+    // Update entire texture (partial updates are tricky with stride)
+    if (bd->FrameTexture)
+    {
+        SDL_UpdateTexture(bd->FrameTexture, nullptr, bd->Framebuffer.data(), bd->FrameWidth * (int) sizeof(Uint32));
+        SDL_RenderCopy(bd->SDLRenderer, bd->FrameTexture, nullptr, nullptr);
+    }
+}
+
+bool ImGui_ImplSDLRenderer_CreateFontsTexture()
+{
+    ImGuiIO& io = ImGui::GetIO();
+    ImGui_ImplSDLRenderer_Data* bd = ImGui_ImplSDLRenderer_GetBackendData();
+    IM_ASSERT(bd != nullptr);
+
+    unsigned char* pixels = nullptr;
+    int width = 0, height = 0;
+    io.Fonts->GetTexDataAsRGBA32(&pixels, &width, &height);
+    if (width <= 0 || height <= 0 || pixels == nullptr)
+        return false;
+
+    bd->FontPixels.resize((size_t) width * (size_t) height);
+    memcpy(bd->FontPixels.data(), pixels, (size_t) width * (size_t) height * sizeof(ImU32));
+    bd->FontWidth = width;
+    bd->FontHeight = height;
+
+    if (bd->FontTexture)
+    {
+        SDL_DestroyTexture(bd->FontTexture);
+        bd->FontTexture = nullptr;
+    }
+
+    bd->FontTexture = SDL_CreateTexture(bd->SDLRenderer, SDL_PIXELFORMAT_ABGR8888, SDL_TEXTUREACCESS_STATIC, width, height);
+    if (bd->FontTexture == nullptr)
+    {
+        SDL_Log("Failed to create font texture: %s", SDL_GetError());
+        bd->FontPixels.clear();
+        bd->FontWidth = 0;
+        bd->FontHeight = 0;
+        return false;
+    }
+
+    SDL_UpdateTexture(bd->FontTexture, nullptr, pixels, width * 4);
+    SDL_SetTextureBlendMode(bd->FontTexture, SDL_BLENDMODE_BLEND);
+
+    io.Fonts->SetTexID((ImTextureID) (intptr_t) bd->FontTexture);
+    return true;
+}
+
+void ImGui_ImplSDLRenderer_DestroyFontsTexture()
+{
+    ImGuiIO& io = ImGui::GetIO();
+    ImGui_ImplSDLRenderer_Data* bd = ImGui_ImplSDLRenderer_GetBackendData();
+    if (bd == nullptr)
+        return;
+
+    if (bd->FontTexture)
+    {
+        SDL_DestroyTexture(bd->FontTexture);
+        bd->FontTexture = nullptr;
+    }
+
+    bd->FontPixels.clear();
+    bd->FontWidth = 0;
+    bd->FontHeight = 0;
+    io.Fonts->SetTexID(nullptr);
+}
+
+bool ImGui_ImplSDLRenderer_CreateDeviceObjects()
+{
+    return ImGui_ImplSDLRenderer_CreateFontsTexture();
+}
+
+void ImGui_ImplSDLRenderer_DestroyDeviceObjects()
+{
+    ImGui_ImplSDLRenderer_Data* bd = ImGui_ImplSDLRenderer_GetBackendData();
+    if (bd == nullptr)
+        return;
+
+    ImGui_ImplSDLRenderer_DestroyFontsTexture();
+
+    if (bd->FrameTexture)
+    {
+        SDL_DestroyTexture(bd->FrameTexture);
+        bd->FrameTexture = nullptr;
+    }
+
+    bd->Framebuffer.clear();
+    bd->FrameWidth = 0;
+    bd->FrameHeight = 0;
+    bd->HasDirtyRegion = false;
+}
+
+#endif // SDL_VERSION_ATLEAST(2,0,17)
